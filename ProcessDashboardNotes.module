<?php namespace ProcessWire;

/**
* Process Dashboard Notes Module for ProcessWire
* This module enables developers to post messages in the ProcessWire Admin for remote collaboration and development support.
* Messages can be classed according to priority, access-controlled, threaded into conversations and expired.
*
* @author Francis Otieno (Kongondo)
*
* https://github.com/kongondo/ProcessDashboardNotes
* Created 24 February 2019
*
* ProcessWire 3.x
* Copyright (C) 2016 by Ryan Cramer
*
* Licensed under MIT v2, see LICENSE.TXT
*
* http://www.processwire.com
*
*/

class ProcessDashboardNotes extends Process implements Module {

	/**
	 * Return information about this module (required)
	 *
	 * @access public
	 *
	 */
	public static function getModuleInfo() {

		// @User role needs 'dashboard-notes' permission
		// @$permission = 'dashboard-notes';
		// @Installs MarkupMenuBuilder

		return array(
			'title' => 'Dashboard Notes: Process',
			'summary' => 'Create messages in ProcessWire Admin',
			'author' => 'Francis Otieno (Kongondo)',
			'version' => 1,
			'href' => 'http:// processwire.com/talk/topic/xxxx/',// @todo
			'singular' => true,
			'autoload' => false,
			'permission' => 'dashboard-notes',
			'requires' => 'FieldtypeComments'
		);

	}


	const PAGE_NAME = 'dashboard-notes';

	// @todo: delete as appropriate!

	/**
	 * Property to return this module's admin page (parent of all menus).
	 *
	 */
	protected $dashboardNotesParent;

	/**
	 * Property to store include children setting (boolean).
	 *
	 */
	private $includeChildren;

	/**
	 * Property to store disable items setting (boolean).
	 *
	 */
	private $disableItems;

	/**
	 * string name of the cookie used to save limit of posts to show per page in posts dashboard.
	 *
	 */
	private $cookieName;

	/**
	 * int value of number of posts/categories/tags to show per page respective dashboard page.
	 *
	 */
	private $showLimit;


	// other single menu properties
	private $menuItems;
	private $menuPages;
	private $dashboardNotesSettings;

	// multilingual
	private $menuItemsLanguages;

	/**
	 * Initialise the module. This is an optional initialisation method called before any execute methods.
	 *
	 * Initialises various class properties ready for use throughout the class.
	 *
	 * @access public
	 *
	 */
	public function init() {

		$user = $this->wire('user');

		if ($this->wire('permissions')->get('dashboard-notes')->id && !$user->hasPermission('dashboard-notes'))
			 throw new WirePermissionException("You have no permission to use this module");

		$modules = $this->wire('modules');
		$modules->get("Jquery");
		$ui = $modules->get("JqueryUI");
		$ui->use("modal");
		// @todo; needed? if not, delete!
		$modules->get("JqueryMagnific");

		// @todo; delete when done! not needed
		$this->dashboardNotesParent = $this->wire('page');

		// @todo; delete when done! not needed
		// cookie per user to save state of number of menus to display per pagination screen in execute()
		$this->cookieName = $user->id . '-dashboardnotes';

		// @todo; delete when done! not needed?
		// default number of menus to show in dashboard notes landing page if no custom limit set (via post/session cookie).
		$this->showLimit = 10;

		parent::init();

	}

	/* ######################### - MARKUP BUILDERS - ######################### */

	/**
	 * Displays a list of the menus.
	 *
	 * This function is executed when a menu with Dashboard Notes Process assigned is accessed.
	 *
	 * @access public
	 * @return string $form Form markup.
	 *
	 */
	public function ___execute() {

		$out = '';

		$baseURL = $this->wire('config')->urls->admin . "dashboard-notes";
		$addURL = $baseURL . "/add/?modal=1";
		$settingsURL = $baseURL . "/settings/";

		$addNoteText = $this->_('Add note');
		$allNoteSettingsText = $this->_('Settings');

		$out .=
			 "<div>" .
				"<ul>" .
					"<li><a href='{$addURL}' class='pw-modal pw-modal-medium'><span>{$addNoteText}</span></a></li>" .
					"<li><a href='{$settingsURL}'><span>{$allNoteSettingsText}</span></a></li>" .
				"</ul>" .

			"</div>";

		return $out;

		$modules = $this->wire('modules');
		$post = $this->wire('input')->post;

		// CREATE A NEW FORM
		$form = $modules->get('InputfieldForm');
		$form->attr('id', 'dashboard-notes');
		$form->action = './';
		$form->method = 'post';

		// CREATE A NEW WRAPPER
		$w = new InputfieldWrapper;

		// quick create menu markup
		$w->add($this->buildQuickCreateMenuMarkup());
		// menus table/list markup
		$w->add($this->buildMenusTableMarkup());
		// actions markup
		if ($this->menusTotal !=0) $w->add($this->buildMenusActionsMarkup());

		// add to form for rendering
		$form->add($w);

		// send input->post values to the Method save();
		if($post->menus_action_btn || $post->menu_new_unpublished_btn || $post->menu_new_published_btn) $this->save($form);

		// render the final form
		return $form->render();

	}

	/**
	 * Renders a single menu for editing. @todo
	 *
	 * Called when the URL is Menu Builders page URL + "/edit/"
	 * note: matches what is appended after ___execute below.
	 *
	 * @access public
	 * @return string $form Form markup.
	 *
	 */
	public function ___executeAdd() {



		$modules = $this->wire('modules');


		// create form for adding new note (page)
		$form = $modules->get('InputfieldForm');
		$form->attr('id', 'dn_new_note');
		$form->action = './';
		$form->method = 'post';
		$form->description = $this->_('New Note');

		// new note: title (text)
		$f = $modules->get('InputfieldText');
		$f->attr('name', 'dn_note_title');
		$f->description = $this->_('Note title.');
		$f->label = $this->_('Title');
		$f->required = true;

		$form->add($f);

		// new note: inputfield selector
		$f = $modules->get('InputfieldTextarea');
		$f->attr('name', 'dn_note_text');
		$f->label = $this->_('Text');// @todo: change label?
		$f->description = $this->_('Note text.');
		$f->required = true;
		$f->rows = 5;

		$form->add($f);

		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_priority');
		$f->attr('value', 2);
		$f->label =  $this->_('Priority');
		//$f->collapsed = Inputfield::collapsedYes;
		$f->notes = $this->_('Specify note priority/urgency.');

		$radioOptions = array (
			1 => $this->_('Low'),
			2 => $this->_('Normal'),
			3 => $this->_('High'),
	 	);

		$f->addOptions($radioOptions);

		$form->add($f);

		#########

		// new inputfieldwrapper
		$wrapper = new InputfieldWrapper();
		$wrapper->attr('title', $this->_('Settings'));
		$id = $this->className() . 'Settings';
		$wrapper->attr('id', $id);

		/* ## note visibility ## */

		$fieldset = $modules->get('InputfieldFieldset');
		$fieldset->attr('id', 'dn_note_settings');
		$fieldset->label = $this->_('Note Settings');

		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_visibility_limit');
		$f->attr('value', 1);
		$f->label =  $this->_('Note Visibility');
		$f->collapsed = Inputfield::collapsedYes;
		$f->notes = $this->_('Specify who should be able to view this note. You can limit by roles, permissions or users. Otherwise, the note will be visible to all who can access Dashboard Notes.');

		$radioOptions = array (
			1 => $this->_('Visible to all with Dashboard Notes Access'),
			2 => $this->_('Roles'),
			3 => $this->_('Permissions'),
			4 => $this->_('Users'),
	 	);

		$f->addOptions($radioOptions);

		$fieldset->add($f);

		// @todo: move to function + show if!

		// note visibility: by role
		$f = $modules->get('InputfieldAsmSelect');
		$f->attr('name', "dn_limit_role");
		//$f->collapsed = Inputfield::collapsedYes;
		$f->label = $this->_('Roles Limit');
		$f->description = $this->_("Select roles allowed to view this note.");
		$f->showIf = 'dn_note_visibility_limit=2';
		$f->requiredIf = 'dn_note_visibility_limit=2';

		$roles = $this->getRoles();

		$f->addOptions($roles);

		$fieldset->add($f);

		// note visibility: by permission
		$f = $modules->get('InputfieldAsmSelect');
		$f->attr('name', "dn_limit_permission");
		//$f->collapsed = Inputfield::collapsedYes;
		$f->label = $this->_('Permissions Limit');
		$f->description = $this->_("Select permissions allowed to view this note.");
		$f->showIf = 'dn_note_visibility_limit=3';
		$f->requiredIf = 'dn_note_visibility_limit=3';

		$permissions = $this->getPermissions();

		$f->addOptions($permissions);

		$fieldset->add($f);

		// note visibility: by permission
		$f = $modules->get('InputfieldAsmSelect');
		$f->attr('name', "dn_limit_users");
		//$f->collapsed = Inputfield::collapsedYes;
		$f->label = $this->_('Users Limit');
		$f->description = $this->_("Select users who can view this note.");
		$f->showIf = 'dn_note_visibility_limit=4';
		$f->requiredIf = 'dn_note_visibility_limit=4';

		$users = $this->getUsers();

		$f->addOptions($users);

		$fieldset->add($f);

		########

		$form->add($fieldset);

		// new note: submit button
		$f = $modules->get('InputfieldButton');
		$f->attr('id+name', 'dn_new_note_btn');
		$f->value = $this->_('Save');
		$f->attr('type', 'submit');

		$form->add($f);



		// post new note for saving
		$post = $this->wire('input')->post;
		if($post->dn_new_note_btn){
			// @todo: saving here!
		}

		return $form->render();

	}

	/**
	 * Renders a single menu for editing. @todo
	 *
	 * Called when the URL is Menu Builders page URL + "/edit/"
	 * note: matches what is appended after ___execute below.
	 *
	 * @access public
	 * @return string $form Form markup.
	 *
	 */
	public function ___executeSettings() {

		$dashboardNotesURL = $this->wire('config')->urls->admin . "dashboard-notes/";

		$backlinkText = $this->_('Back to all Notes. Add back icon here');

		$out =
			 "<div>" .
				"<a href='{$dashboardNotesURL}'><span>{$backlinkText}</span></a>" .
			"</div>";

		$out .= "<div>Settings for all notes. Backlink to all notes</div>";
		return $out;


		$modules = $this->wire('modules');
		$post = $this->input->post;

		// get the menu (page) we are editing
		$menuID = (int) $this->wire('input')->get->id;
		$menu = $this->wire('pages')->get("id=$menuID, parent=$this->dashboardNotesParent, include=all");// only get menu pages!

		$form = $modules->get('InputfieldForm');

		// if we found a valid menu page
		if($menu->id) {

			// menu settings
			$this->dashboardNotesSettings = $menu->dashboard_notes_settings ? json_decode($menu->dashboard_notes_settings, true) : array();
			// fetch this menu's JSON string with menu pages properties (pages find selector and inputfield to use)
			$this->menuPages = $menu->menu_pages ? json_decode($menu->menu_pages, true) : array();
			// fetch this menu's JSON string with menu items properties
			$this->menuItems = $menu->menu_items ? json_decode($menu->menu_items, true) : array();
			// if multilingual, active MB languages
			$this->menuItemsLanguages = isset($this->menuPages['menu_items_languages']) ? $this->menuPages['menu_items_languages'] : null;

			##############################

			$this->nestedSortableConfigs();
			$this->menuConfigs();// @note: we check if user has right permission in the method itself

			// check if menu is published or not
			$menu->is(Page::statusUnpublished) ? $pubStatus = 1 : $pubStatus = '';

			// check if menu is locked for editing
			$menu->is(Page::statusLocked) ? $editStatus = 1 : $editStatus = '';

			$editStatusNote = $editStatus ? $this->_(' (locked)') : '';

			// add a breadcrumb that returns to our main page @todo - don't show non-superadmins breadcrumbs?
			$this->breadcrumbs->add(new Breadcrumb('../', $this->wire('page')->title));
			$this->headline(sprintf(__('Edit menu: %s'), $menu->title) . $editStatusNote); // headline when editing a menu

			$form->attr('id', 'MenuBuilderEdit');
			$form->action = './';
			$form->method = 'post';

			############################################ - prep for tabs - ############################################

			$menuPages = $this->menuPages;

			// set include children + disable items status + for users with right permission
			if(count($menuPages)) {
				// enable include children feature
				if(isset($menuPages['children']) && $this->wire('user')->hasPermission('dashboard-notes-include-children')) {
					$this->includeChildren = $menuPages['children'];
				}
				// enable 'enable/disable' items feature
				if(isset($menuPages['disable_items']) && $this->wire('user')->hasPermission('dashboard-notes-disable-items')) {
					$this->disableItems = $menuPages['disable_items'];
				}
			}

			/***************** Add input buttons to Fourth tab *****************/

			$m = $modules->get('InputfieldHidden');
			$m->attr('name', 'menu_id');
			$m->attr('value', $menuID);
			$form->add($m);

			$m = $modules->get('InputfieldSubmit');
			$m->class .= ' head_button_clone';
			$m->attr('id+name', 'menu_save');
			$m->class .= " menu_save";// add a custom class to this submit button
			$m->attr('value', $this->_('Save'));
			$form->add($m);

			$m = $modules->get('InputfieldSubmit');
			$m->attr('id+name', 'menu_save_exit');
			$m->class .= " ui-priority-secondary";
			$m->class .= " menu_save";// add a custom class to this submit button
			$m->attr('value', $this->_('Save & Exit'));
			$form->add($m);

			return $form->render();

		}// end if $menu


		############################################ - if input->post - ############################################

		// if saving menu
		elseif($post->menu_save || $post->menu_save_exit || $post->note_delete) $this->save($form);
		// else invalid menu ID or no ID provided (e.g. /edit/)
		else $this->wire('session')->redirect($this->wire('page')->url);// redirect to landing page

	}

	/**
	 * Displays a nested list (menu items) of a single menu.
	 *
	 * This is a recursive function to display list of menu items.
	 * Also displays each menu item's settings.
	 *
	 * @access private
	 * @param integer $parent ID of menu items.
	 * @param integer $first Helper variable to designate first menu item. Ensures CSS Class 'sortable' is output only once.
	 * @return string $out Menu items markup.
	 *
	 */
	private function renderNotes($parent = 0, $first = 0) {

		$menuID = (int) $this->wire('input')->get->id;

		if($menuID) {

			/*
				INPUTS

					- id: item id of the menu item in relation to the menu (not same as pages_id!)
					- title: the menu item title as saved in Build Menu (note: even PW native page->title can be customised)
					- parent_id: the parent of this menu item in relation to the menu (note: does not have to reflect PW tree!; top tier items have parent_id = 0)
					- url: the url of the menu item (if PW, use native $page->url; if custom use provided url)
					- css_itemid: this menu item's CSS ID (optional)
					- css_itemclass: this menu items's CSS Class (optional)
					- pages_id: for PW pages items = $page->id; for custom menu items = 0 (note: this is different from id!)
					- optional include children feature
					- opitional disable menu items feature

			 */


			$out = '';

			$has_child = false;

			// $id is = id; $item = arrays of title, url, newtab, etc
			foreach ($this->menuItems as $id => $item) {

				## - MENU ITEM PROPERTIES - ##

				// set on the fly properties
				$this->itemID = $id;

				$this->itemTitle = $item['title'];
				$this->itemTitle2 = $this->wire('sanitizer')->entities($this->itemTitle);// for value of title input
				$this->itemURL = isset($item['url']) ? $item['url'] : '';

				// if multilingual, also set language specific titles and urls
				// @note: format is $this->itemTitle_de; $this->itemURL_de; $this->itemTitle2_de, etc...
				if(!is_null($this->menuItemsLanguages)) $this->setLanguageTitlesAndURLs($item);

				// items without parent ids are top level items
				// we give them an ID of 0 for display purposes (we won't save the value [see wireEncodeJSON()])
				$this->itemParentID = isset($item['parent_id']) ? $item['parent_id'] : 0;
				$this->cssItemID = isset($item['css_itemid']) ? $item['css_itemid'] : '';
				$this->cssItemClass = isset($item['css_itemclass']) ? $item['css_itemclass'] : '';
				$this->itemPagesID = isset($item['pages_id']) ? $item['pages_id'] : 0;// only PW pages will have a pages_id > 0 (equal to their PW page->id)
				$this->newTab = isset($item['newtab']) ? $item['newtab'] : 0;
				$this->itemIncludeChildren = isset($item['include_children']) ? $item['include_children'] : '';
				$this->itemMenuMaxLevel = isset($item['m_max_level']) ? $item['m_max_level'] : '';
				$this->disabledItem = isset($item['disabled_item']) ? $item['disabled_item'] : '';

				// custom menu items
				if(!$this->itemPagesID) {
					$this->itemType = $this->_('Custom');
					$this->readOnly = '';
				}
				// pw page menu items
				else {
					$this->itemType = $this->_('Page');
					$this->readOnly = ' readonly';
					$this->itemURL = $this->wire('pages')->get($this->itemPagesID)->path;
				}

				## - BUILD MENU - ##

				######################### item is a parent #########################
				// if this menu item is a parent; create the inner-items/child-menu-items
				if ($this->itemParentID == $parent) {
					// if this is the first child output '<ol>' with the class 'sortable'
					if ($has_child === false) {
						$has_child = true;// This is a parent
						if ($first == 0){
							$out .= "<ol id='sortable_main' class='sortable'>\n";
							$first = 1;
						}
						else $out .= "\n<ol>\n";
					}

					######################### menu item drag n drop handle #########################
					$out .= $this->buildMenuItemDragDropHandleMarkup();
					######################### item settings #########################
					$out .=  $this->buildMenuItemSettingsPanel();
					######################### generate sub-menu items [recursion] #########################
					// call function again to generate nested list for sub-menu items belonging to this menu item.
					$out .= $this->listMenu($id, $first);
					// close the <li>
					$out .= "</li>\n";
				}// end if parent

			}// end foreach $this->menuItems as $id => $item

			if ($has_child === true) $out .= "</ol>\n";

			return $out;

		}// end if menuID

	}


	/* ######################### - CRUD ACTIONS - ######################### */

	/**
	 * Processes ProcessDashboardNotes form inputs (CRUD).
	 *
	 * CRUD - Processes all the form input sent from execute() and executeEdit().
	 *
	 * @access private
	 * @param object $form Sent form values.
	 *
	 */
	private function save($form) {

		$post = $this->wire('input')->post;

		// process form
		$form->processInput($post);

		$menuID = (int) $post->menu_id;
		$menuDeleteConfirm = (int) $post->menu_delete_confirm;// checkbox to confirm trash

		// save new menu(s)
		if ($post->menu_new_unpublished_btn || $post->menu_new_published_btn)$this->saveNewMenu($post);
		// menus bulk actions: lock/unlock and trash/delete are controlled by permissions
		elseif($post->menus_action_btn) $this->bulkActionsMenu($post);
		// save single specified menu
		elseif($post->menu_save || $post->menu_save_exit) $this->saveSingleMenu($menuID, $post);
		// delete menu
		elseif ($post->note_delete) $this->noteDelete($menuDeleteConfirm);

	}

	/**
	 * Delete a single menu item. @todo: bulk trash those marked for trash? I think so!
	 *
	 * @access private
	 * @param integer $menuID ID of the Menu to delete.
	 *
	 */
	private function noteDelete($menuID) {

		if($menuID) {

			$page = $this->wire('page');
			$pages = $this->wire('pages');

			// if user does not have permission to trash/delete a menu, exit with an error
			if ($this->wire('permissions')->get('dashboard-notes-delete')->id && !$this->wire('user')->hasPermission('dashboard-notes-delete')) {
				$this->error($this->_('Dashboard Notes: You have no permission to delete menus.'));
				$this->session->redirect($page->url. 'edit/?id=' . $menuID);// redirect back to the menu we were editing
			}

			$menu = $pages->get("id=$menuID, parent=$this->dashboardNotesParent, include=all");

			// if menu is locked for editing, exit with an error
			if($menu->is(Page::statusLocked)) {
				$this->error($this->_('Dashboard Notes: This menu is locked for edits.'));
				$this->session->redirect($page->url. 'edit/?id=' . $menuID);// redirect back to the menu we were editing
			}

			if($pages->trash($menu)) {
				// also delete cache of menu if present
				$this->deleteMenuCache($menu->id);
				$this->message(sprintf($this->_('Dashboard Notes: Moved menu %1$s to trash: %2$s'), $menu->title, $menu->url));// tell user menu trashed
				$this->session->redirect($page->url);
			}

			else {
				$this->error($this->_('Dashboard Notes: Unable to move menu to trash'));// menu can't be moved to the trash error
				return false;
			}

		}

	}


	/**
	 * Save new menus.
	 *
	 * @access private
	 * @param array $post Input Post with new menus to save.
	 * @access private
	 *
	 */
	private function saveNewMenu($post) {

		$sanitizer = $this->wire('sanitizer');
		$addMenus = $post->menus_add_text;// $addMenus will be a string of text separated by a new line (\n).
		$newUnpublishedBtn = $post->menu_new_unpublished_btn;

		if ($addMenus) {

			$failed = array();
			$menus = explode("\n", $addMenus);// convert to an array

			// Sanitize and save new menus

			$i = 0;// set counter for number of menus added
			foreach ($menus as $m) {
				$p = new Page();
				$p->parent = $this->dashboardNotesParent;
				$p->template = $this->wire('templates')->get("menus");
				$p->title = $sanitizer->text($m);
				if (!$p->title) continue;// skip to next if no title provided
				if ($p->title) $p->name = $sanitizer->pageName($p->title);// sanitize and convert to a URL friendly page name

				// check if name already taken
				if($p->parent->child("name={$p->name}, include=all")->id) {
					// if the name already exists, add it to the $failed array [to display to user in error message later] and skip to next title
					$failed [] = $p->title;
					continue;
				}

				// if user pressed 'save unpublished', we save new menus unpublished
				if ($newUnpublishedBtn) $p->addStatus(Page::statusUnpublished);
				$p->save();
				$i++;

			}// end foreach $menus as $m

			// create a string of "failed" menu titles to add to error message
			$failedTitles = implode(', ', $failed);

			if($i > 0) $this->message(sprintf(_n("Added %d new menu.", "Added %d new menus.", $i), $i));// tell user how many menus were added
			if($failedTitles) $this->error($this->_("Some menus not added because names already in use. These are: {$failedTitles}."));
			$this->session->redirect($this->wire('page')->url);// redirect to landing page

		}// end if $addMenus

		// show error message if add button clicked without first entering some categories to add
		else $this->error($this->_("Dashboard Notes: You need to add some menus."));

	}

	/* ######################### - GETTERS - ######################### */

	/**
	 * Undocumented function @todo
	 *
	 * @return void
	 */
	private function getRoles() {
		$roles = array();
		foreach($this->wire('roles') as $role) {
			if($role->name == 'guest') continue;
			$roles[$role->id] = $role->name;
		}
		return $roles;
	}

	/**
	 * Undocumented function @todo
	 *
	 * @return void
	 */
	private function getPermissions() {
		$permissions = array();
		foreach($this->wire('permissions') as $permission) {
			$permissions[$permission->id] = $permission->get("title|name");
		}
		return $permissions;
	}

	/**
	 * Undocumented function @todo
	 *
	 * @return void
	 */
	private function getUsers() {
		$users = array();
		foreach($this->wire('users') as $user) {
			if($user->name == 'guest') continue;
			$users[$user->id] = $user->name;
		}
		return $users;
	}



	/* ######################### - INSTALLERS - ######################### */


	/**
	 * Called only when the module is installed.
	 *
	 * A new page with this Process module assigned is created.
	 * A new permission 'dashboard-notes' is created.
	 * 3 fields are created.
	 * A new template 'menu_pages' is created.
	 *
	 * @access public
	 *
	 */
	public function ___install() {

		// create ProcessDashboardNotes admin page and permission if verifyInstall() was successful in its validation
		if($this->verifyInstall($mode = null) == true) {
			$page = new Page();
			$page->template = 'admin';
			$page->parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
			$page->title = 'Dashboard Notes';
			$page->name = self::PAGE_NAME;
			$page->process = $this;
			#$page->addStatus(Page::statusHidden);
			$page->save();

			$this->verifyInstall($mode = 1);// run Dashboard Notes Installer

			// tell the user we created this page
			$this->message("Dashboard Notes: Created page {$page->path}");
		}

		else throw new WireException($this->_('Dashboard Notes: Installation aborted. Check and fix reported errors first.'));

		// create the permission 'dashboard-notes' and 'dashboard-notes-settings' to limit access to the module
		$perms = array(
			'dashboard-notes' => $this->_('Use Dashboard Notes'),
			// @todo?
			//'dashboard-notes-settings' => $this->_('Edit Dashboard Notes Settings'),
		);

		foreach ($perms as $k => $v) {
			$permission = $this->wire('permissions')->get($k);
			if (!$permission->id) {
				$p = new Permission();
				$p->name = $k;
				$p->title = $v;
				$p->save();
			}
		}

		// tell the user we created this module's permissions
		//$this->message('Dashboard Notes: Created new permissions dashboard-notes and dashboard-notes-settings.');
		$this->message('Dashboard Notes: Created new permission dashboard-notes.');

	}

	/**
	 * Called only when the module is uninstalled.
	 *
	 * This should return the site to the same state it was in before the module was installed.
	 * Deletes 3 fields, template and permission created on install as well as created menu pages.
	 *
	 * @access public
	 *
	 */
	public function ___uninstall() {

		$pages = $this->wire('pages');

		// find and delete the page we installed, locating it by the process field (which has the module ID)
		// it would probably be sufficient just to locate by name, but this is just to be extra sure.
		$moduleID = $this->wire('modules')->getModuleID($this);
		$dnPage = $pages->get("template=admin, process=$moduleID, name=" . self::PAGE_NAME);
		// $page = $pages->get('template=admin, name='.self::PAGE_NAME);

		if($dnPage->id) {
			// if we found the page, let the user know and delete it
			$this->message($this->_('Dashboard Notes: Deleted Page: ') . $dnPage->path);
			// recursively delete the dashboard notes page (i.e. including all its children (the note parent and its children the notes pages))
			$pages->delete($dnPage, true);
			// also delete any note pages that may have been left in the trash
			foreach ($pages->find('template=dashboard-note, status>=' . Page::statusTrash) as $p) $p->delete();
		}

		// find and delete the Dashboard Notes permissions and let the user know
		// @note: @todo: currently using only 1 permission!
		//$perms = array('dashboard-notes','dashboard-notes-settings');
		$perms = array('dashboard-notes');

		foreach ($perms as $p) {
			$permission = $this->wire('permissions')->get($p);
			if ($permission->id) $permission->delete();
		}

		// tell the user we created this module's permission
		// @note: @todo: currently using only 1 permission!
		//$this->message('Dashboard Notes: Deleted permissions dashboard-notes and dashboard-notes-settings.');
		$this->message('Dashboard Notes: Deleted permission dashboard-notes.');

		#############

		// find and delete the 2 templates used by our notes
		$templates = array('dashboard-note', 'dashboard-notes');
		foreach ($templates as $template) {
			$t = $this->wire('templates')->get($template);
			if($t->id) {
				$this->wire('templates')->delete($t);
				$this->wire('fieldgroups')->delete($t->fieldgroup);// delete the associated fieldgroups
			}
		}
		$this->message('Dashboard Notes: Deleted Templates dashboard-note and dashboard-notes');

		#############

		// find and delete the 2 fields used by our notes
		$fields = array('dashboard_note', 'dashboard_notes_settings');
		foreach ($fields as $field) {
			$f = $this->wire('fields')->get($field);
			if($f->id) $this->wire('fields')->delete($f);
		}
		$this->message('Dashboard Notes: Deleted Fields dashboard_note and dashboard_notes_settings');

	}

	/**
	 * Check if similar fields, templates and dashboard notes page exist before install.
	 *
	 * @access public
	 * @param null|integer $mode Whether to verify install possible (null) or commence install (1).
	 *
	 */
	public function verifyInstall($mode = null) {

		$pageCheck = '';

		// if we have already verified install, proceed directly to first step of installer
		if($mode == 1) return $this->createFields();

		// 1. ###### First we check if Dashboard Notes Admin page, fields and templates already exist.
		// If yes to any of these, we abort installation and return error messages

		// check if Dashboard Notes page already exists in Admin
		$parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$page = $this->wire('pages')->get("parent=$parent, template=admin, include=all, name=".self::PAGE_NAME);
		if($page->id && $page->id > 0) $pageCheck = $page->title;

		$pageExist = $pageCheck ? true : false;// we'll use this later + $pageCheck to show error

		// check if Dashboard Notes fields already exist
		$fields  = array('note' => 'dashboard_note','settings' => 'dashboard_notes_settings');

		$fieldsCheck = array();
		foreach ($fields as $key => $value) {if($this->wire('fields')->get($value))	$fieldsCheck [] = $this->wire('fields')->get($value)->name;}
		$fieldsExist = count($fieldsCheck) ? true : false;

		$templates = array('note' => 'dashboard-note','notes' => 'dashboard-notes');

		$templatesCheck = array();
		foreach ($templates as $template) {if($this->wire('templates')->get($template)) $templatesCheck [] = $this->wire('templates')->get($template)->name;}

		$templatesExist = count($templatesCheck) ? true : false;

		if($pageExist == true){
			$failedPage = $pageCheck;
			$this->error($this->_("Cannot install Dashboard Notes Admin page. A page named 'dashboard-notes' is already in use under Admin. Its title is: {$failedPage}."));
		}

		if($fieldsExist == true){
			$failedFields = implode(', ', $fieldsCheck);
			$this->error($this->_("Cannot install Dashboard Notes fields. Some field names already in use. These are: {$failedFields}."));
		}

		if($templatesExist == true){
			$failedTemplates = implode(', ', $templatesCheck);
			$this->error($this->_("Cannot install Dashboard Notes templates. Some template names already in use. These are: {$failedTemplates}."));
		}

		//if any of our checks returned true, we abort early
		if($pageExist == true || $fieldsExist == true || $templatesExist == true) {
			throw new WireException($this->_('Due to the above errors, Dashboard Notes did not install. Make necessary changes and try again.'));
			//due to above errors, we stop executing install of the following 'templates', 'fields' and 'pages'
		}

		// pass on to first step of install
		// return true to OK first step of install
		return true;

	}

	/**
	 * Create several Dashboard Notes fields.
	 *
	 * @note: We create from JSON using Field::setImportData().
	 *
	 * @access private
	 * @return $this->createTemplates().
	 *
	 */
	private function createFields() {

		// 2. ###### We create the fields we will need to add to our templates ######

		$fields = $this->getFieldData();
		$fieldNames = '';

		foreach ($fields as $fieldName => $fieldData) {
			$f = new Field();
			$f->setImportData($fieldData);
			$f->save();
			$fieldNames .= $fieldName . " ";
		}

		$this->message("Dashboard Notes: Created fields $fieldNames");

		// lets create some templates and add our fields to them
		return $this->createTemplates();

	}

	/**
	 * Create several Dashboard Notes templates.
	 *
	 * Create templates one each for the Dashboard Notes Notes parent and for individual Notes pages.
	 * @note: We create from JSON using Template::setImportData().
	 *
	 * @access private
	 * @return $this->extraTemplateSettings().
	 *
	 */
	private function createTemplates() {

		// 3. ###### We create the templates needed by Dashboard Notes ######

		$templates = $this->getTemplateData();
		$templateNames = '';

		foreach ($templates as $templateName => $templateData) {
			$fg = new Fieldgroup();
			$fg->name = $templateName;
			$templateNames .= $templateName . " ";
			foreach ($templateData['fieldgroupFields'] as $fieldname) $fg->add($fieldname);
			$fg->save();
			$t = new Template();
			$t->setImportData($templateData) ;
			$t->save();
		}

		$this->message("Dashboard Notes: Created templates $templateNames");

		/* @todo?
		// need to create this blank template file 'dashboard-notes.php' to enable MM to appear in the admin menu (view-access issues)
		$path = $this->wire('config')->paths->templates . 'dashboard-notes.php';
		if(!is_file($path)) {
			$notice = "<?php namespace ProcessWire;\n\n#### - Intentionally left blank. Please do not delete this file - ###";
			$notesTemplateFile = fopen($path, 'a');
			fwrite($notesTemplateFile, $notice);
			fclose($notesTemplateFile);
		}*/

		// add some extra settings ('allowed templates for children' doesn't seem to work with setImportData()? so we do it ourselves)
		return $this->extraTemplateSettings();

	}

	/**
	 * Add extra settings for the 4 dashboard-specific templates.
	 *
	 * @access private
	 * @return $this->createPages().
	 *
	 */
	private function extraTemplateSettings() {
		// 4. ###### post-creating our templates: additional settings for the child and parent notes templates ######

		$allowedChildTemplate = $this->wire('templates')->get("dashboard-note");
		$pt = $this->wire('templates')->get('dashboard-notes');

		// allowed child template for template 'dashboard-notes'
		$pt->childTemplates = array($allowedChildTemplate->id);// needs to be added as array of template IDs
		$pt->save();

		// allowed parent template for individual notes template
		// @note: this should work at JSON level but it's not, so doing it here as well
		$allowedChildTemplate->parentTemplates = array($pt->id);// needs to be added as array of template IDs
		$allowedChildTemplate->save();

		return $this->createPages();

	}

	/**
	 * Return JSON data for installing fields for the module.
	 *
	 * @access private
	 * @return string $fieldsJSON JSON string containing fields data for use with Field::setImportData().
	 *
	 */
	private function getFieldData() {
		$fieldsJSON = file_get_contents(__DIR__ . "/configs/fields.json");
		return json_decode($fieldsJSON, true);
	}

	/**
	 * Return JSON data for installing templates for the module.
	 *
	 * @access private
	 * @return string $templatesJSON JSON string containing templates data for use with Template::setImportData().
	 *
	 */
	private function getTemplateData() {
		$templatesJSON = file_get_contents(__DIR__ . "/configs/templates.json");
		return json_decode($templatesJSON, true);
	}

	/**
	 * Create notes parent page.
	 *
	 *
	 * @access private
	 *
	 */
	private function createPages() {

		// 5. ###### Create the 1 parent dashboard notes page

		$a = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$parent = $a->child('name=dashboard-notes');
		$template = $this->wire('templates')->get('dashboard-notes');

		// create the child page of 'Dashboard Notes': This is the parent page of all notes pages!
		$p = new Page();
		$p->template = $template;
		$p->parent = $parent;
		$p->title = "Notes";
		// @note: saving as hidden; we don't want to show in AdminThemeReno side menu
		$p->addStatus(Page::statusHidden);
		$p->save();

	}


}
