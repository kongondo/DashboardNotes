<?php namespace ProcessWire;

/**
* Process Dashboard Notes Module for ProcessWire
* This module enables developers to post messages in the ProcessWire Admin for remote collaboration and development support.
* Messages can be classed according to priority, access-controlled, threaded into conversations and expired.
*
* @author Francis Otieno (Kongondo)
*
* https://github.com/kongondo/ProcessDashboardNotes
* Created 24 February 2019
*
* ProcessWire 3.x
* Copyright (C) 2016 by Ryan Cramer
*
* Licensed under MIT v2, see LICENSE.TXT
*
* http://www.processwire.com
*
*/

class ProcessDashboardNotes extends Process implements Module {

	/**
	 * Return information about this module (required)
	 *
	 * @access public
	 *
	 */
	public static function getModuleInfo() {

		// @User role needs 'dashboard-notes' permission
		// @$permission = 'dashboard-notes';
		// @Installs MarkupMenuBuilder

		return array(
			'title' => 'Dashboard Notes: Process',
			'summary' => 'Create messages in ProcessWire Admin',
			'author' => 'Francis Otieno (Kongondo)',
			'version' => 1,
			'href' => 'http:// processwire.com/talk/topic/xxxx/',// @todo
			'singular' => true,
			'autoload' => false,
			'permission' => 'dashboard-notes',
			'requires' => 'FieldtypeComments'
		);

	}


	const PAGE_NAME = 'dashboard-notes';

	// @todo: delete as appropriate!

	/**
	 * Property to return this module's admin page (parent of all menus).
	 *
	 */
	protected $dashboardNotesParent;

	/**
	 * Property to store include children setting (boolean).
	 *
	 */
	private $includeChildren;

	/**
	 * Property to store disable items setting (boolean).
	 *
	 */
	private $disableItems;

	/**
	 * string name of the cookie used to save limit of posts to show per page in posts dashboard.
	 *
	 */
	private $cookieName;

	/**
	 * int value of number of posts/categories/tags to show per page respective dashboard page.
	 *
	 */
	private $showLimit;


	// other single menu properties
	private $menuItems;
	private $menuPages;
	private $dashboardNotesSettings;

	// multilingual
	private $menuItemsLanguages;

	/**
	 * Initialise the module. This is an optional initialisation method called before any execute methods.
	 *
	 * Initialises various class properties ready for use throughout the class.
	 *
	 * @access public
	 *
	 */
	public function init() {

		$user = $this->wire('user');

		if ($this->wire('permissions')->get('dashboard-notes')->id && !$user->hasPermission('dashboard-notes'))
			 throw new WirePermissionException("You have no permission to use this module");

		$this->wire('modules')->get('JqueryWireTabs');
		$config = $this->wire('config');
		$config->scripts->add($this->config->urls->ProcessDashboardNotes . 'scripts/jquery.mjs.nestedSortable.js');
		$config->scripts->add($this->config->urls->ProcessDashboardNotes . 'scripts/jquery.asmselect-mb.js');

		$this->dashboardNotesParent = $this->wire('page');

		// cookie per user to save state of number of menus to display per pagination screen in execute()
		$this->cookieName = $user->id . '-dashboardnotes';

		// default number of menus to show in dashboard notes landing page if no custom limit set (via post/session cookie).
		$this->showLimit = 10;

		parent::init();

	}

	/* ######################### - MARKUP BUILDERS - ######################### */

	/**
	 * Displays a list of the menus.
	 *
	 * This function is executed when a menu with Dashboard Notes Process assigned is accessed.
	 *
	 * @access public
	 * @return string $form Form markup.
	 *
	 */
	public function ___execute() {

		$out = '';

		$out .=
			 "<div>" .
				 "<p>Each note is a page. The page has two fields: (i)a plain textarea field for settings specific to the note. This will hold json values for: note importance (urgent, priority, low, etc); note color (hex); note view permission type (role/permission/user ID); note view permission ID (id of role(s), permission(s), or user(s)). (ii) A FieldtypeComments field with ratings disabled but conversation enabled, avatars disabled, etc. The key here is the conversation. We create/update/delete/read comments using the API. However, if possible, we can do the READ using the render comments methods of the field instead! Remember, we are using this in the backend only! Maybe a check for that as well?</p>" .
				 "<p>Notes will have a parent page called Notes? Naah, we can just house them as children of the module page! However challenge here will be if we need global settings! If so, we can have a Notes parent page with a plain textarea field that we save JSON values to. What sort of global settings would we want though? We would want settings related to the comments field, for instance. E.g. reply depth? More? email notifications?</p>".
				 "<p>We will need to check if FieldtypeComments is installed!</p>".
				"<p>Draggable cards? What about the conversation flow then? Maybe cards and click more to see conversation? In that case, open in new window?</p>".
			"</div>";

		return $out;

		$modules = $this->wire('modules');
		$post = $this->wire('input')->post;

		// CREATE A NEW FORM
		$form = $modules->get('InputfieldForm');
		$form->attr('id', 'dashboard-notes');
		$form->action = './';
		$form->method = 'post';

		// CREATE A NEW WRAPPER
		$w = new InputfieldWrapper;

		// quick create menu markup
		$w->add($this->buildQuickCreateMenuMarkup());
		// menus table/list markup
		$w->add($this->buildMenusTableMarkup());
		// actions markup
		if ($this->menusTotal !=0) $w->add($this->buildMenusActionsMarkup());

		// add to form for rendering
		$form->add($w);

		// send input->post values to the Method save();
		if($post->menus_action_btn || $post->menu_new_unpublished_btn || $post->menu_new_published_btn) $this->save($form);

		// render the final form
		return $form->render();

	}

	/**
	 * Renders a single menu for editing.
	 *
	 * Called when the URL is Menu Builders page URL + "/edit/"
	 * note: matches what is appended after ___execute below.
	 *
	 * @access public
	 * @return string $form Form markup.
	 *
	 */
	public function ___executeEdit() {


		$modules = $this->wire('modules');
		$post = $this->input->post;

		// get the menu (page) we are editing
		$menuID = (int) $this->wire('input')->get->id;
		$menu = $this->wire('pages')->get("id=$menuID, parent=$this->dashboardNotesParent, include=all");// only get menu pages!

		$form = $modules->get('InputfieldForm');

		// if we found a valid menu page
		if($menu->id) {

			// menu settings
			$this->dashboardNotesSettings = $menu->dashboard_notes_settings ? json_decode($menu->dashboard_notes_settings, true) : array();
			// fetch this menu's JSON string with menu pages properties (pages find selector and inputfield to use)
			$this->menuPages = $menu->menu_pages ? json_decode($menu->menu_pages, true) : array();
			// fetch this menu's JSON string with menu items properties
			$this->menuItems = $menu->menu_items ? json_decode($menu->menu_items, true) : array();
			// if multilingual, active MB languages
			$this->menuItemsLanguages = isset($this->menuPages['menu_items_languages']) ? $this->menuPages['menu_items_languages'] : null;

			##############################

			$this->nestedSortableConfigs();
			$this->menuConfigs();// @note: we check if user has right permission in the method itself

			// check if menu is published or not
			$menu->is(Page::statusUnpublished) ? $pubStatus = 1 : $pubStatus = '';

			// check if menu is locked for editing
			$menu->is(Page::statusLocked) ? $editStatus = 1 : $editStatus = '';

			$editStatusNote = $editStatus ? $this->_(' (locked)') : '';

			// add a breadcrumb that returns to our main page @todo - don't show non-superadmins breadcrumbs?
			$this->breadcrumbs->add(new Breadcrumb('../', $this->wire('page')->title));
			$this->headline(sprintf(__('Edit menu: %s'), $menu->title) . $editStatusNote); // headline when editing a menu

			$form->attr('id', 'MenuBuilderEdit');
			$form->action = './';
			$form->method = 'post';

			############################################ - prep for tabs - ############################################

			$menuPages = $this->menuPages;

			// set include children + disable items status + for users with right permission
			if(count($menuPages)) {
				// enable include children feature
				if(isset($menuPages['children']) && $this->wire('user')->hasPermission('dashboard-notes-include-children')) {
					$this->includeChildren = $menuPages['children'];
				}
				// enable 'enable/disable' items feature
				if(isset($menuPages['disable_items']) && $this->wire('user')->hasPermission('dashboard-notes-disable-items')) {
					$this->disableItems = $menuPages['disable_items'];
				}
			}

			/***************** Add input buttons to Fourth tab *****************/

			$m = $modules->get('InputfieldHidden');
			$m->attr('name', 'menu_id');
			$m->attr('value', $menuID);
			$form->add($m);

			$m = $modules->get('InputfieldSubmit');
			$m->class .= ' head_button_clone';
			$m->attr('id+name', 'menu_save');
			$m->class .= " menu_save";// add a custom class to this submit button
			$m->attr('value', $this->_('Save'));
			$form->add($m);

			$m = $modules->get('InputfieldSubmit');
			$m->attr('id+name', 'menu_save_exit');
			$m->class .= " ui-priority-secondary";
			$m->class .= " menu_save";// add a custom class to this submit button
			$m->attr('value', $this->_('Save & Exit'));
			$form->add($m);

			return $form->render();

		}// end if $menu


		############################################ - if input->post - ############################################

		// if saving menu
		elseif($post->menu_save || $post->menu_save_exit || $post->menu_delete) $this->save($form);
		// else invalid menu ID or no ID provided (e.g. /edit/)
		else $this->wire('session')->redirect($this->wire('page')->url);// redirect to landing page

	}

	/**
	 * Displays a nested list (menu items) of a single menu.
	 *
	 * This is a recursive function to display list of menu items.
	 * Also displays each menu item's settings.
	 *
	 * @access private
	 * @param integer $parent ID of menu items.
	 * @param integer $first Helper variable to designate first menu item. Ensures CSS Class 'sortable' is output only once.
	 * @return string $out Menu items markup.
	 *
	 */
	private function listMenu($parent = 0, $first = 0) {

		$menuID = (int) $this->wire('input')->get->id;

		if($menuID) {

			/*
				INPUTS

					- id: item id of the menu item in relation to the menu (not same as pages_id!)
					- title: the menu item title as saved in Build Menu (note: even PW native page->title can be customised)
					- parent_id: the parent of this menu item in relation to the menu (note: does not have to reflect PW tree!; top tier items have parent_id = 0)
					- url: the url of the menu item (if PW, use native $page->url; if custom use provided url)
					- css_itemid: this menu item's CSS ID (optional)
					- css_itemclass: this menu items's CSS Class (optional)
					- pages_id: for PW pages items = $page->id; for custom menu items = 0 (note: this is different from id!)
					- optional include children feature
					- opitional disable menu items feature

			 */


			$out = '';

			$has_child = false;

			// $id is = id; $item = arrays of title, url, newtab, etc
			foreach ($this->menuItems as $id => $item) {

				## - MENU ITEM PROPERTIES - ##

				// set on the fly properties
				$this->itemID = $id;

				$this->itemTitle = $item['title'];
				$this->itemTitle2 = $this->wire('sanitizer')->entities($this->itemTitle);// for value of title input
				$this->itemURL = isset($item['url']) ? $item['url'] : '';

				// if multilingual, also set language specific titles and urls
				// @note: format is $this->itemTitle_de; $this->itemURL_de; $this->itemTitle2_de, etc...
				if(!is_null($this->menuItemsLanguages)) $this->setLanguageTitlesAndURLs($item);

				// items without parent ids are top level items
				// we give them an ID of 0 for display purposes (we won't save the value [see wireEncodeJSON()])
				$this->itemParentID = isset($item['parent_id']) ? $item['parent_id'] : 0;
				$this->cssItemID = isset($item['css_itemid']) ? $item['css_itemid'] : '';
				$this->cssItemClass = isset($item['css_itemclass']) ? $item['css_itemclass'] : '';
				$this->itemPagesID = isset($item['pages_id']) ? $item['pages_id'] : 0;// only PW pages will have a pages_id > 0 (equal to their PW page->id)
				$this->newTab = isset($item['newtab']) ? $item['newtab'] : 0;
				$this->itemIncludeChildren = isset($item['include_children']) ? $item['include_children'] : '';
				$this->itemMenuMaxLevel = isset($item['m_max_level']) ? $item['m_max_level'] : '';
				$this->disabledItem = isset($item['disabled_item']) ? $item['disabled_item'] : '';

				// custom menu items
				if(!$this->itemPagesID) {
					$this->itemType = $this->_('Custom');
					$this->readOnly = '';
				}
				// pw page menu items
				else {
					$this->itemType = $this->_('Page');
					$this->readOnly = ' readonly';
					$this->itemURL = $this->wire('pages')->get($this->itemPagesID)->path;
				}

				## - BUILD MENU - ##

				######################### item is a parent #########################
				// if this menu item is a parent; create the inner-items/child-menu-items
				if ($this->itemParentID == $parent) {
					// if this is the first child output '<ol>' with the class 'sortable'
					if ($has_child === false) {
						$has_child = true;// This is a parent
						if ($first == 0){
							$out .= "<ol id='sortable_main' class='sortable'>\n";
							$first = 1;
						}
						else $out .= "\n<ol>\n";
					}

					######################### menu item drag n drop handle #########################
					$out .= $this->buildMenuItemDragDropHandleMarkup();
					######################### item settings #########################
					$out .=  $this->buildMenuItemSettingsPanel();
					######################### generate sub-menu items [recursion] #########################
					// call function again to generate nested list for sub-menu items belonging to this menu item.
					$out .= $this->listMenu($id, $first);
					// close the <li>
					$out .= "</li>\n";
				}// end if parent

			}// end foreach $this->menuItems as $id => $item

			if ($has_child === true) $out .= "</ol>\n";

			return $out;

		}// end if menuID

	}

	/**
	 * Outputs javascript configuration value for other menu features.
	 *
	 * @access protected
	 * @return object $scripts Object with array of configurations to pass to JS.
	 *
	 */
	protected function menuConfigs() {

		// our default include children setting
		$options = array('config' => array('children' => 0));// do not include children

		// @todo: this could be refactored!
		if(count($this->menuPages)) {
			// if a custom 'include children' setting found, we overwrite the default one
			foreach ($this->menuPages as $key => $value) {
				if($key == 'children' && $this->wire('user')->hasPermission('dashboard-notes-include-children')) {
					$options['config'][$key] = $value;
					break;
				}
			}

			// set multilingual status
			$options['config']['multilingual'] = isset($this->menuPages['menu_items_languages']) ? 1 : 0;
		}
		// ProcessDashboardNotes
		$scripts = $this->wire('config')->js($this->className(), $options);

		return $scripts;

	}

	/* ######################### - CRUD ACTIONS - ######################### */

	/**
	 * Processes ProcessDashboardNotes form inputs (CRUD).
	 *
	 * CRUD - Processes all the form input sent from execute() and executeEdit().
	 *
	 * @access private
	 * @param object $form Sent form values.
	 *
	 */
	private function save($form) {

		$post = $this->wire('input')->post;

		// process form
		$form->processInput($post);

		$menuID = (int) $post->menu_id;
		$menuDeleteConfirm = (int) $post->menu_delete_confirm;// checkbox to confirm trash

		// save new menu(s)
		if ($post->menu_new_unpublished_btn || $post->menu_new_published_btn)$this->saveNewMenu($post);
		// menus bulk actions: lock/unlock and trash/delete are controlled by permissions
		elseif($post->menus_action_btn) $this->bulkActionsMenu($post);
		// save single specified menu
		elseif($post->menu_save || $post->menu_save_exit) $this->saveSingleMenu($menuID, $post);
		// delete menu
		elseif ($post->menu_delete) $this->menuDelete($menuDeleteConfirm);

	}

	/**
	 * Delete a single menu item.
	 *
	 * @access private
	 * @param integer $menuID ID of the Menu to delete.
	 *
	 */
	private function menuDelete($menuID) {

		if($menuID) {

			$page = $this->wire('page');
			$pages = $this->wire('pages');

			// if user does not have permission to trash/delete a menu, exit with an error
			if ($this->wire('permissions')->get('dashboard-notes-delete')->id && !$this->wire('user')->hasPermission('dashboard-notes-delete')) {
				$this->error($this->_('Dashboard Notes: You have no permission to delete menus.'));
				$this->session->redirect($page->url. 'edit/?id=' . $menuID);// redirect back to the menu we were editing
			}

			$menu = $pages->get("id=$menuID, parent=$this->dashboardNotesParent, include=all");

			// if menu is locked for editing, exit with an error
			if($menu->is(Page::statusLocked)) {
				$this->error($this->_('Dashboard Notes: This menu is locked for edits.'));
				$this->session->redirect($page->url. 'edit/?id=' . $menuID);// redirect back to the menu we were editing
			}

			if($pages->trash($menu)) {
				// also delete cache of menu if present
				$this->deleteMenuCache($menu->id);
				$this->message(sprintf($this->_('Dashboard Notes: Moved menu %1$s to trash: %2$s'), $menu->title, $menu->url));// tell user menu trashed
				$this->session->redirect($page->url);
			}

			else {
				$this->error($this->_('Dashboard Notes: Unable to move menu to trash'));// menu can't be moved to the trash error
				return false;
			}

		}

	}

	/**
	 * Save a single menu item.
	 *
	 * @param integer $menuID ID of the Menu to delete.
	 * @param array $post Post input with a menu's settings.
	 * @access private
	 *
	 */
	private function saveSingleMenu($menuID, $post) {

		//  ================ SAVE SINGLE EXISTING MENU (executeEdit()) =====================

		$user = $this->wire('user');
		$sanitizer = $this->wire('sanitizer');
		$page = $this->wire('page');
		$pages = $this->wire('pages');

		$menu = $pages->get($menuID);

		// if we didn't get a menu, exit with an error
		if(!$menu->id) {
			$this->error($this->_('Dashboard Notes: Error saving Menu.'));
			return false;
		}

		// if menu is locked for editing, exit with an error
		if($menu->is(Page::statusLocked)) {
			$this->error($this->_('Dashboard Notes: This menu is locked for edits.'));
			$this->wire('session')->redirect($page->url . 'edit/?id=' . $menuID);// redirect back to the menu we were editing
		}

		################# process menu #################

		$menuTitle = $sanitizer->text($post->menu_title);

		// if no title provided, halt proceedings and show error message
		if (!$menuTitle) {
			$this->error($this->_('Dashboard Notes: A title is required.'));
			return false;
		}

		$menu->title = $menuTitle;
		$menu->name = $sanitizer->pageName($menuTitle);

		#################	01. Process menu 'pages'	#################
		$menu->menu_pages = $this->saveSingleMenuPages($menu, $post);
		#################	02. Process EXISTING menu items 	#################
		$menu->menu_items = $this->saveSingleMenuItems($post);
		#################	03. Process menu settings 	#################
		if($user->hasPermission('dashboard-notes-settings')) $menu->dashboard_notes_settings = $this->saveSingleMenuSettings($post);// only save for users with right permission

		#################	Save menu 	#################
		$menu->save();

		// also delete cache of menu if present so that can be refreshed
		$this->deleteMenuCache($menu->id);

		$this->message($this->_('Dashboard Notes: Saved Menu '. $menu->title));
		if($post->menu_save_exit) $this->wire('session')->redirect($page->url);
		else $this->wire('session')->redirect($page->url . 'edit/?id=' . $menuID);// redirect back to the menu we were editing

	}

	/**
	 * Save a single menu 'pages' settings.
	 *
	 * Here pages refer mainly to settings that affect the whole menu.
	 * These include, allow markup, etc.
	 *
	 * @access private
	 * @param object $menu Page representing the menu being edited.
	 * @param object $post The Post containing all 'pages' values to be saved for this menu.
	 * @return string $menuPagesJSON JSON String to save as settings for this menu.
	 *
	 */
	private function saveSingleMenuPages($menu, $post) {

		$user = $this->wire('user');
		$sanitizer = $this->wire('sanitizer');

		// array for newly set menuPages settings ('sel', 'input', 'markup' and 'children')
		$menuPagesNew = array();

		// only save for users with correct permissions
		// ensures their settings are not overwritten (although hidden for other users)

		// if this user has permission to SPECIFY pages selectable as menu items in AsmSelect and PageAutocomplete
		if($user->hasPermission('dashboard-notes-selectable')) {
			// selector for finding pages that can be added to the menu (for AsmSelect/Autocomplete)
			$menuPagesNew['sel'] = $sanitizer->text($post->menu_pages);
		}

		// if user has permission to allow changing of page field type used to select pages to add as menu items [AsmSelect vs PageAutocomplete]
		if($user->hasPermission('dashboard-notes-page-field')) {
			// page inputfield type for finding pages that can be added to the menu (AsmSelect vs. Autocomplete)
			// we only save this if user selects Autocomplete; otherwise defaults to AsmSelect
			//$menuPagesNew['input'] = (int) $post->menu_pages_select == 2 ? 2 : '';
			$menuPagesNew['input'] = '';
			$selPageField = (int) $post->menu_pages_select;
			if($selPageField == 2) $menuPagesNew['input'] = 2;
			elseif($selPageField == 3) $menuPagesNew['input'] = 3;
		}

		// if user can change and use allow markup/HTML setting
		if($user->hasPermission('dashboard-notes-markup')) {
			// whether to allow HTML markup in menu item titles/lables -> e.g. <span>Home</span>
			// we only save this if user selects Yes; otherwise defaults to No (don't allow markup)
			// we'll then use the correct sanitizer below
			$this->allowMarkup = $menuPagesNew['markup'] = (int) $post->menu_item_title_markup == 1 ? 1 : '';
		}

		// if user can change and use include children setting
		if($user->hasPermission('dashboard-notes-include-children')) {
			// we only save this if user selects Yes; otherwise defaults to No (don't allow inclusion of children)
			// we'll then use the correct sanitizer below
			$this->includeChildren = $menuPagesNew['children'] = (int) $post->menu_item_include_children == 1 ? 1 : '';
		}

		// if user can change and use disable items setting
		if($user->hasPermission('dashboard-notes-disable-items')) {
			// we only save this if user selects Yes; otherwise defaults to No (don't allow disabling of menu items)
			$this->disableItems = $menuPagesNew['disable_items'] = (int) $post->menu_item_disable_items == 1 ? 1 : '';
		}

		// if user can change and use multi-lingual menu items feature
		if($user->hasPermission('dashboard-notes-multi-lingual-items')) {
			$this->menuItemsLanguages = $menuPagesNew['menu_items_languages'] = count($post->menu_items_languages) ? $post->menu_items_languages : '';
		}

		// merge newly set menuPages values with (any) existing ones
		$menuPagesSaved = json_decode($menu->menu_pages, true);
		if(!is_array($menuPagesSaved)) $menuPagesSaved = array();
		$menuPages = array_merge($menuPagesSaved, $menuPagesNew);

		// JSON string of menu pages and menu items to save
		$menuPagesJSON = count($menuPages) ? wireEncodeJSON($menuPages) : '';// using wireEncodeJSON ensures we only save non-empty values

		return $menuPagesJSON;

	}

	/**
	 * Save a single menu's menu items.
	 *
	 * @access private
	 * @param object $post The Post containing all menu items and their properties.
	 * @return string $menuitemsJSON JSON String to save as menu items for this menu.
	 *
	 */
	private function saveSingleMenuItems($post) {

		#################	01. Process existing menu items 	#################
		$menuItems = $this->saveSingleMenuItemsExisting($post);
		// we'll need this to auto-increment menu IDs for new menu items (to ensure uniqueness)
		$lastID = count($menuItems) ? max(array_keys($menuItems)) : 0;// will give us the highest numbered array key (the itemID)

		$this->menuItemID = $lastID + 1;

		#################	02: Process NEW custom menu items 	#################
		$menuItems = $this->saveSingleMenuItemsNewCustom($post, $menuItems);
		#################	03: Process NEW menu items from PW Pages 	#################
		$this->setSingleMenuItemsNewPagesArrays($post);
		$menuItems = $this->saveSingleMenuItemsNewPages($menuItems);
		#################	04: Process NEW menu items from Selector 	#################
		$menuItems = $this->saveSingleMenuItemsNewSelector($post, $menuItems);

		$menuitemsJSON = count($menuItems) ? wireEncodeJSON($menuItems) : '';

		return $menuitemsJSON;

	}

	/**
	 * Prepare data for existing menu items within a menu being saved.
	 *
	 * @access private
	 * @param object $post The Post containing all menu items and their properties.
	 * @return array $menuItems Array populated with data for existing menu items for menu being saved.
	 *
	 */
	private function saveSingleMenuItemsExisting($post) {

		$user = $this->wire('user');
		$sanitizer = $this->wire('sanitizer');

		// array to hold our all our menu items
		$menuItems = array();
		// for mutlilingual titles and custom URLs if needed
		$menuItemsLanguage = array();

		// to hold IDs of disabled items to action cascading same status to descendants
		$disabledItemsIDs = array();

		// loop through the existing, updated menu items sent from nestedSortable
		// only loop if we have existing menu times. we check the hidden field with IDs of menu items
		if(count($post->item_id)) {

			//$ml = $this->multiLingual ? true : false;
			$ml = !is_null($this->menuItemsLanguages) ? true : false;

			//$itemIncludeChildren = '';
			//$itemMMaxLevel = '';

			if($this->allowMarkup) $purifier = $this->wire('modules')->get('MarkupHTMLPurifier');

			foreach($post->item_id as $itemID) {

				$itemMMaxLevel = '';

				$itemID = (int) $itemID;
				if(!$itemID) continue;

				// if menu items titles allow HTML (markup) && user has correct permission, we run them though HTML purifier
				if($this->allowMarkup && $user->hasPermission('dashboard-notes-markup')) $itemTitle = $purifier->purify($post->item_title[$itemID]);
				// else we sanitize menu item titles as text
				else $itemTitle =  $sanitizer->text($post->item_title[$itemID]);

				if(!$itemTitle) continue;

				$itemURL = $sanitizer->url($post->item_url[$itemID]);
				if(!$itemURL) continue;

				$itemParent = (int) $post->item_parent[$itemID];// the item's parent in relation to the menu (not PW page menu!)
				$itemPagesID = (int) $post->pages_id[$itemID];
				$itemURL = $itemPagesID == 0 ? $itemURL : '';// only save custom (external to PW) items links

				// add multilingual titles and URLs (for custom menu items only)
				if($ml) $menuItemsLanguage = $this->saveSingleMenuItemsExistingLanguagesTitleURL($itemID, $itemPagesID, $post, $menuItemsLanguage);

				$itemCSSID = $sanitizer->name($post->css_itemid[$itemID]);// single value
				$itemCSSClass = $sanitizer->text($post->css_itemclass[$itemID]);// sanitizer->text to accept multiple classes
				$itemNewTab = isset($post->newtab[$itemID]) ? 1 : '';// only save for custom menu items with target='_blank'

				// if current user can edit include children values + change include children setting
				$itemIncludeChildren = '';
				if( $this->includeChildren && isset($post->include_children[$itemID]) ) {
					// no need to save default value '4'
					$itemIncludeChildren =  (int) $post->include_children[$itemID] == 4 ? '' : (int) $post->include_children[$itemID];
					// @todo: For now, only m_max_level can be individually set
					$itemMMaxLevel = $itemIncludeChildren == 1 || $itemIncludeChildren == 3 ? (int) $post->mb_max_level[$itemID] : '';
				}

				// if current user can edit enable/disable menu items feature + change items enabled status
				$itemDisabled = $this->disableItems && isset($post->disabled_item[$itemID]) ? 1 : '';

				// if parent is disabled, then disable all descendants as well
				if(in_array($itemParent, $disabledItemsIDs)) $itemDisabled = 1;

				$menuItems[$itemID] = array(
					'title' => $itemTitle,
					'parent_id' => $itemParent,
					'url' => $itemURL,
					'pages_id' => $itemPagesID,
					'css_itemid' => $itemCSSID,
					'css_itemclass' => $itemCSSClass,
					'newtab' => $itemNewTab,
					'include_children' => $itemIncludeChildren,
					'm_max_level' => $itemMMaxLevel,
					'disabled_item' => $itemDisabled,
				);

				// add disabled item to array to check if to apply same status to descendants
				if($itemDisabled) $disabledItemsIDs[] = $itemID;

			}// end foreach loop for existing menu items

			// merge menu items with multilingual titles and custom URLs if applicable
			if(count($menuItemsLanguage)) $menuItems = array_replace_recursive($menuItems, $menuItemsLanguage);

		}// end if count $post->item_id

		return $menuItems;

	}

	/**
	 * Prepare multi-lingual data for existing menu items within a menu being saved.
	 *
	 * @access private
	 * @param integer $itemID The ID of the menu item being prepared for saving.
	 * @param integer $itemPagesID The pages ID of the menu item. If 0, it means a custom menu item.
	 * @param object $post The Post containing the menu item's multi-lingual properties.
	 * @param array $menuItemsLanguage Array with data for existing menu items multi-lingual titles and URLs for menu being saved.
	 * @return array $menuItemsLanguage Updated array with data for existing menu items multi-lingual titles and URLs for menu being saved.
	 *
	 */
	 private function saveSingleMenuItemsExistingLanguagesTitleURL($itemID, $itemPagesID, $post, $menuItemsLanguage) {

		 $user = $this->wire('user');
		 $sanitizer = $this->wire('sanitizer');
		 if($this->allowMarkup) $purifier = $this->wire('modules')->get('MarkupHTMLPurifier');

		 foreach($this->getLanguages(1) as $langName => $langTitle) {// @note: 1 means skip non-active languages

		 	if($langName == 'default') continue;

		 	$suffix = '_' . $langName;

		 	## language title ##
		 	// if menu items titles allow HTML (markup) && user has correct permission, we run them though HTML purifier
			if($this->allowMarkup && $user->hasPermission('dashboard-notes-markup')){
				$itemLanguageTitle = $purifier->purify($post->{"item_title{$suffix}"}[$itemID]);
			}
			// else we sanitize menu item title as text
			else $itemLanguageTitle = $sanitizer->text($post->{"item_title{$suffix}"}[$itemID]);

			## language url ##
			$itemLanguageURL = $itemPagesID == 0 ? $sanitizer->url($post->{"item_url{$suffix}"}[$itemID]) : '';// only save custom (external to PW) items links

			##################

		 	$titleIndex = 'title' . $suffix;
		 	$urlIndex = 'url' . $suffix;

		 	$menuItemsLanguage[$itemID][$titleIndex] = $itemLanguageTitle;
		 	$menuItemsLanguage[$itemID][$urlIndex] = $itemLanguageURL;

		 }// end foreach

		 return $menuItemsLanguage;

	}

	/**
	 * Prepare data for new (pw) pages menu items from added pages for the menu being saved.
	 *
	 * @access private
	 * @param array $menuItems Array with data for menu items being prepared for saving.
	 * @return array $menuItems Updated array with data for menu items to save.
	 *
	 */
	private function saveSingleMenuItemsNewPages($menuItems) {

		$menuItemID = $this->menuItemID;
		$pages = $this->wire('pages');
		$sanitizer = $this->wire('sanitizer');
		// for multilingual environments
		$language = $this->wire('user')->language; // save the current user's language

		$count = count($this->addPages);

		for ($i = 0; $i < $count; $i++) {

			// if there are menu items added from the AsmSelect, add them to the menu
			$itemID = (int) $this->addPages[$i];// sanitize: we need this to be an integer

			// multilingual environments
			if($language != null && method_exists($pages->get($itemID)->title, 'getLanguageValue')) $itemTitle = $pages->get($itemID)->title->getLanguageValue($language);// title of each PW page in this array
			else $itemTitle = $pages->get($itemID)->title;// title of each PW page in this array
			if(!$itemTitle) continue;// if no new pages posted, move on...[otherwise one iteration with empty strings is added to array!]

			$itemCSSID = isset($this->pagesCSSID[$i]) ? $sanitizer->name($this->pagesCSSID[$i]) : '';
			$itemCSSClass = isset($this->pagesCSSClass[$i]) ? $sanitizer->text($this->pagesCSSClass[$i]) : '';

			// include children (but not for custom menu items or 'Home')
			$itemIncludeChildren = '';
			if(isset($this->pagesIncludeChildren[$i])) {
				$itemIncludeChildren = (int) $this->pagesIncludeChildren[$i] == 4 || $itemID == 1 ? '' : (int) $this->pagesIncludeChildren[$i];
			}

			// @todo: only m_max_level can be individually set for now
			$itemMMaxLevel = $itemIncludeChildren == 1 || $itemIncludeChildren == 3 ? (int) $this->pagesMBMaxLevel[$i] : '';
			#$itemBMaxLevel = $itemIncludeChildren == 2 ? (int) $this->pagesMBMaxLevel[$i] : '';

			// @todo - not setting individually for now
			// determine m and b_max_levels when 'Both' selection made in include children level (and if there's need for separate levels)
			/*if($itemIncludeChildren == 3) {
				$itemMBMaxLevels = explode(',', $pagesMBMaxLevel[$i]);
				$itemMMaxLevel = (int) $itemMBMaxLevels['0'];
				$itemBMaxLevel = isset($itemMBMaxLevels['1']) && $itemMBMaxLevels['1'] ? (int) $itemMBMaxLevels['1'] : $itemMMaxLevel;
			}*/

			// add PW pages (internal) menu items to our menu
			$menuItems[$menuItemID] = array(
				'title' => $itemTitle,
				'parent_id' => 0,// for new items before they are sorted in drag & drop
				// 'url' => '',// empty since these are PW pages; no needed to copy URL here + need to make sure always have latest
				'css_itemid' => $itemCSSID,
				'css_itemclass' => $itemCSSClass,
				'pages_id' => $itemID,// the PW page ID
				// 'newtab' => '',// NOT necessary for PW pages
				'include_children' => $itemIncludeChildren,
				'm_max_level' => $itemMMaxLevel,
				// 'b_max_level' => $itemBMaxLevel,// @todo - not setting individually for now
			);

			$menuItemID++;

		}// end for loop for new page items


		$this->menuItemID = $menuItemID;

		return $menuItems;

	}

	/**
	 * Prepare data for new (pw) pages menu items from selector for the menu being saved.
	 *
	 * @access private
	 * @param object $post The Post containing the selector for adding menu items.
	 * @param array $menuItems Array with data for menu items being prepared for saving.
	 * @return array $menuItems Updated array with data for menu items to save.
	 *
	 */
	private function saveSingleMenuItemsNewSelector($post, $menuItems) {

		$menuItemID = $this->menuItemID;
		$pages = $this->wire('pages');
		$sanitizer = $this->wire('sanitizer');
		$language = $this->wire('user')->language; // save the current user's language

		$items = array();

		$selectorPages = $sanitizer->text($post->item_addselector);
		if($selectorPages) {
			$sel = ", template!=admin, has_parent!=2, parent!=7, id!=27";// prevent accidental addition of admin|trash|404 pages
			$items = $pages->find($selectorPages . $sel);
		}

		if (count($items)) {

			foreach ($items as $item) {

				// add PW pages (internal) menu items from the selector to our menu
				$menuItems[$menuItemID] = array(
					// multilingual environments
					'title' => $title = is_null($language) ? $item->title : $item->title->getLanguageValue($language),
					'parent_id' => 0,// for new items before they are sorted in drag & drop
					// 'url' => '',// empty since these are PW pages; no needed to copy URL here + need to make sure always have latest
					// 'css_itemid' => ''// empty until edited
					// 'css_itemclass' => ''// empty until edited
					'pages_id' => $item->id,// the PW page ID
					// 'newtab' => ''// NOT necessary for PW pages
				);

				$menuItemID++;

			}// end foreach $items as $item

		}// end if count($items)

		return $menuItems;

	}

	/**
	 * Save a single menu nestedSortable settings.
	 *
	 * @access private
	 * @param object $post The Post containing all menu settings.
	 * @return string $menuSettingsJSON JSON String to save as settings for this menu.
	 *
	 */
	private function saveSingleMenuSettings($post) {

		$user = $this->wire('user');
		$sanitizer = $this->wire('sanitizer');

		// if user has permission to edit nestedSortable settings
		if($user->hasPermission('dashboard-notes-settings')) {
			// nestedSortable settings for this menu. we'll save this as JSON in dashboard_notes_settings field
			$dashboardNotesSettings = array();
			// nestedSortable settings
			foreach ($post->dashboard_notes_settings as $key => $value) {
				// only save non-empty $key => $values
				if($value) {
					if($key == 'maxLevels' || $key == 'expandOnHover' || $key == 'tabSize') $value = (int) $value;
					else $value = $sanitizer->text($value);
					$dashboardNotesSettings[$key]['setting'] = $value;
				}
			}// end foreach
		}// end if user has dashboard-notes-settings permission

		// JSON string of menu settings to save
		$menuSettingsJSON = count($dashboardNotesSettings) ? json_encode($dashboardNotesSettings) : '';

		return $menuSettingsJSON;

	}

	/**
	 * Apply bulk actions to selected menu items.
	 *
	 * @access private
	 * @param object $post Input Post with action to apply and menu items to apply them to.
	 * @access private
	 *
	 */
	private function bulkActionsMenu($post) {

		$action = $this->wire('sanitizer')->fieldName($post->menus_action_select);

		if (!$action) {
			$this->error($this->_("Dashboard Notes: You need to select an action."));
			return false;
		}

		$actionMenus = $post->menus_action;// checkbox array name

		// check if menus were selected.
		if (count($actionMenus)) {

			// prepare sent menu IDs to find and TRASH the menu pages
			$menuIds = implode('|', $actionMenus);// split array elements, joining them with pipe (I) to use in selector
			$menus = $this->wire('pages')->find("id={$menuIds}, include=all");

			$i = 0;
			# publish
			if ($action == 'publish') {
				foreach ($menus as $m) {
					$m->removeStatus(Page::statusUnpublished);
					$m->save();
					$i++;
				}

				$msg = sprintf(_n("Published %d menu.", "Published %d menus.", $i), $i);

			}// end publish menus

			# unpublish
			elseif ($action == 'unpublish') {
				foreach ($menus as $m) {
					$m->addStatus(Page::statusUnpublished);
					$m->save();
					$i++;
				}

				$msg = sprintf(_n("Unpublished %d menu.", "Unpublished %d menus.", $i), $i);

			}// end unpublish menus

			# lock
			elseif ($action == 'lock') {
				foreach ($menus as $m) {
					$m->addStatus(Page::statusLocked);
					$m->save();
					$i++;
				}

				$msg = sprintf(_n("Locked %d menu.", "Locked %d menus.", $i), $i);

			}// end lock menus

			# unlock
			elseif ($action == 'unlock') {
				foreach ($menus as $m) {
					$m->removeStatus(Page::statusLocked);
					$m->save();
					$i++;
				}

				$msg = sprintf(_n("Unlocked %d menu.", "Unlocked %d menus.", $i), $i);

			}// end unlock menus

			# trash
			elseif ($action == 'trash') {
				foreach ($menus as $m) {
					$m->trash();
					$i++;
					// also delete cache of menu if present
					$this->deleteMenuCache($m->id);
				}

				$msg = sprintf(_n("Trashed %d menu.", "Trashed %d menus.", $i), $i);

			}// end trash menus

			# delete
			elseif ($action == 'delete') {
				foreach ($menus as $m) {
					$m->delete();
					$i++;
					// also delete cache of menu if present
					$this->deleteMenuCache($m->id);
				}

				$msg = sprintf(_n("Deleted %d menu.", "Deleted %d menus.", $i), $i);

			}// end delete menus

			// messages
			$msg = $this->_('Dashboard Notes') . ': ' . $msg;

			$this->message($msg);// tell user how many menus were 'actioned'
			$this->session->redirect($this->wire('page')->url);// redirect to page where we were

		}

		// error
		else {
			// show error message if apply action button clicked without first selecting menus
			$this->error($this->_('Dashboard Notes: You need to select at least one menu before applying an action.'));
			return false;
		}

	}

	/**
	 * Save new menus.
	 *
	 * @access private
	 * @param array $post Input Post with new menus to save.
	 * @access private
	 *
	 */
	private function saveNewMenu($post) {

		$sanitizer = $this->wire('sanitizer');
		$addMenus = $post->menus_add_text;// $addMenus will be a string of text separated by a new line (\n).
		$newUnpublishedBtn = $post->menu_new_unpublished_btn;

		if ($addMenus) {

			$failed = array();
			$menus = explode("\n", $addMenus);// convert to an array

			// Sanitize and save new menus

			$i = 0;// set counter for number of menus added
			foreach ($menus as $m) {
				$p = new Page();
				$p->parent = $this->dashboardNotesParent;
				$p->template = $this->wire('templates')->get("menus");
				$p->title = $sanitizer->text($m);
				if (!$p->title) continue;// skip to next if no title provided
				if ($p->title) $p->name = $sanitizer->pageName($p->title);// sanitize and convert to a URL friendly page name

				// check if name already taken
				if($p->parent->child("name={$p->name}, include=all")->id) {
					// if the name already exists, add it to the $failed array [to display to user in error message later] and skip to next title
					$failed [] = $p->title;
					continue;
				}

				// if user pressed 'save unpublished', we save new menus unpublished
				if ($newUnpublishedBtn) $p->addStatus(Page::statusUnpublished);
				$p->save();
				$i++;

			}// end foreach $menus as $m

			// create a string of "failed" menu titles to add to error message
			$failedTitles = implode(', ', $failed);

			if($i > 0) $this->message(sprintf(_n("Added %d new menu.", "Added %d new menus.", $i), $i));// tell user how many menus were added
			if($failedTitles) $this->error($this->_("Some menus not added because names already in use. These are: {$failedTitles}."));
			$this->session->redirect($this->wire('page')->url);// redirect to landing page

		}// end if $addMenus

		// show error message if add button clicked without first entering some categories to add
		else $this->error($this->_("Dashboard Notes: You need to add some menus."));

	}

	/* ######################### - INSTALLERS - ######################### */


	/**
	 * Called only when the module is installed.
	 *
	 * A new page with this Process module assigned is created.
	 * A new permission 'dashboard-notes' is created.
	 * 3 fields are created.
	 * A new template 'menu_pages' is created.
	 *
	 * @access public
	 *
	 */
	public function ___install() {

		// create ProcessDashboardNotes admin page and permission if verifyInstall() was successful in its validation
		if($this->verifyInstall($mode = null) == true) {
			$page = new Page();
			$page->template = 'admin';
			$page->parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
			$page->title = 'Dashboard Notes';
			$page->name = self::PAGE_NAME;
			$page->process = $this;
			#$page->addStatus(Page::statusHidden);
			$page->save();

			$this->verifyInstall($mode = 1);// run Dashboard Notes Installer

			// tell the user we created this page
			$this->message("Dashboard Notes: Created page {$page->path}");
		}

		else throw new WireException($this->_('Dashboard Notes: Installation aborted. Check and fix reported errors first.'));

		// create the permission 'dashboard-notes' and 'dashboard-notes-settings' to limit access to the module
		$perms = array(
			'dashboard-notes' => $this->_('Use Dashboard Notes'),
			// @todo?
			//'dashboard-notes-settings' => $this->_('Edit Dashboard Notes Settings'),
		);

		foreach ($perms as $k => $v) {
			$permission = $this->wire('permissions')->get($k);
			if (!$permission->id) {
				$p = new Permission();
				$p->name = $k;
				$p->title = $v;
				$p->save();
			}
		}

		// tell the user we created this module's permissions
		//$this->message('Dashboard Notes: Created new permissions dashboard-notes and dashboard-notes-settings.');
		$this->message('Dashboard Notes: Created new permission dashboard-notes.');

	}

	/**
	 * Called only when the module is uninstalled.
	 *
	 * This should return the site to the same state it was in before the module was installed.
	 * Deletes 3 fields, template and permission created on install as well as created menu pages.
	 *
	 * @access public
	 *
	 */
	public function ___uninstall() {

		$pages = $this->wire('pages');

		// find and delete the page we installed, locating it by the process field (which has the module ID)
		// it would probably be sufficient just to locate by name, but this is just to be extra sure.
		$moduleID = $this->wire('modules')->getModuleID($this);
		$dnPage = $pages->get("template=admin, process=$moduleID, name=" . self::PAGE_NAME);
		// $page = $pages->get('template=admin, name='.self::PAGE_NAME);

		if($dnPage->id) {
			// if we found the page, let the user know and delete it
			$this->message($this->_('Dashboard Notes: Deleted Page: ') . $dnPage->path);
			// recursively delete the dashboard notes page (i.e. including all its children (the note parent and its children the notes pages))
			$pages->delete($dnPage, true);
			// also delete any note pages that may have been left in the trash
			foreach ($pages->find('template=dashboard-note, status>=' . Page::statusTrash) as $p) $p->delete();
		}

		// find and delete the Dashboard Notes permissions and let the user know
		// @note: @todo: currently using only 1 permission!
		//$perms = array('dashboard-notes','dashboard-notes-settings');
		$perms = array('dashboard-notes');

		foreach ($perms as $p) {
			$permission = $this->wire('permissions')->get($p);
			if ($permission->id) $permission->delete();
		}

		// tell the user we created this module's permission
		// @note: @todo: currently using only 1 permission!
		//$this->message('Dashboard Notes: Deleted permissions dashboard-notes and dashboard-notes-settings.');
		$this->message('Dashboard Notes: Deleted permission dashboard-notes.');

		#############

		// find and delete the 2 templates used by our notes
		$templates = array('dashboard-note', 'dashboard-notes');
		foreach ($templates as $template) {
			$t = $this->wire('templates')->get($template);
			if($t->id) {
				$this->wire('templates')->delete($t);
				$this->wire('fieldgroups')->delete($t->fieldgroup);// delete the associated fieldgroups
			}
		}
		$this->message('Dashboard Notes: Deleted Templates dashboard-note and dashboard-notes');

		#############

		// find and delete the 2 fields used by our notes
		$fields = array('dashboard_note', 'dashboard_notes_settings');
		foreach ($fields as $field) {
			$f = $this->wire('fields')->get($field);
			if($f->id) $this->wire('fields')->delete($f);
		}
		$this->message('Dashboard Notes: Deleted Fields dashboard_note and dashboard_notes_settings');

	}

	/**
	 * Check if similar fields, templates and dashboard notes page exist before install.
	 *
	 * @access public
	 * @param null|integer $mode Whether to verify install possible (null) or commence install (1).
	 *
	 */
	public function verifyInstall($mode = null) {

		$pageCheck = '';

		// if we have already verified install, proceed directly to first step of installer
		if($mode == 1) return $this->createFields();

		// 1. ###### First we check if Dashboard Notes Admin page, fields and templates already exist.
		// If yes to any of these, we abort installation and return error messages

		// check if Dashboard Notes page already exists in Admin
		$parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$page = $this->wire('pages')->get("parent=$parent, template=admin, include=all, name=".self::PAGE_NAME);
		if($page->id && $page->id > 0) $pageCheck = $page->title;

		$pageExist = $pageCheck ? true : false;// we'll use this later + $pageCheck to show error

		// check if Dashboard Notes fields already exist
		$fields  = array('note' => 'dashboard_note','settings' => 'dashboard_notes_settings');

		$fieldsCheck = array();
		foreach ($fields as $key => $value) {if($this->wire('fields')->get($value))	$fieldsCheck [] = $this->wire('fields')->get($value)->name;}
		$fieldsExist = count($fieldsCheck) ? true : false;

		$templates = array('note' => 'dashboard-note','notes' => 'dashboard-notes');

		$templatesCheck = array();
		foreach ($templates as $template) {if($this->wire('templates')->get($template)) $templatesCheck [] = $this->wire('templates')->get($template)->name;}

		$templatesExist = count($templatesCheck) ? true : false;

		if($pageExist == true){
			$failedPage = $pageCheck;
			$this->error($this->_("Cannot install Dashboard Notes Admin page. A page named 'dashboard-notes' is already in use under Admin. Its title is: {$failedPage}."));
		}

		if($fieldsExist == true){
			$failedFields = implode(', ', $fieldsCheck);
			$this->error($this->_("Cannot install Dashboard Notes fields. Some field names already in use. These are: {$failedFields}."));
		}

		if($templatesExist == true){
			$failedTemplates = implode(', ', $templatesCheck);
			$this->error($this->_("Cannot install Dashboard Notes templates. Some template names already in use. These are: {$failedTemplates}."));
		}

		//if any of our checks returned true, we abort early
		if($pageExist == true || $fieldsExist == true || $templatesExist == true) {
			throw new WireException($this->_('Due to the above errors, Dashboard Notes did not install. Make necessary changes and try again.'));
			//due to above errors, we stop executing install of the following 'templates', 'fields' and 'pages'
		}

		// pass on to first step of install
		// return true to OK first step of install
		return true;

	}

	/**
	 * Create several Dashboard Notes fields.
	 *
	 * @note: We create from JSON using Field::setImportData().
	 *
	 * @access private
	 * @return $this->createTemplates().
	 *
	 */
	private function createFields() {

		// 2. ###### We create the fields we will need to add to our templates ######

		$fields = $this->getFieldData();
		$fieldNames = '';

		foreach ($fields as $fieldName => $fieldData) {
			$f = new Field();
			$f->setImportData($fieldData);
			$f->save();
			$fieldNames .= $fieldName . " ";
		}

		$this->message("Dashboard Notes: Created fields $fieldNames");

		// lets create some templates and add our fields to them
		return $this->createTemplates();

	}

	/**
	 * Create several Dashboard Notes templates.
	 *
	 * Create templates one each for the Dashboard Notes Notes parent and for individual Notes pages.
	 * @note: We create from JSON using Template::setImportData().
	 *
	 * @access private
	 * @return $this->extraTemplateSettings().
	 *
	 */
	private function createTemplates() {

		// 3. ###### We create the templates needed by Dashboard Notes ######

		$templates = $this->getTemplateData();
		$templateNames = '';

		foreach ($templates as $templateName => $templateData) {
			$fg = new Fieldgroup();
			$fg->name = $templateName;
			$templateNames .= $templateName . " ";
			foreach ($templateData['fieldgroupFields'] as $fieldname) $fg->add($fieldname);
			$fg->save();
			$t = new Template();
			$t->setImportData($templateData) ;
			$t->save();
		}

		$this->message("Dashboard Notes: Created templates $templateNames");

		/* @todo?
		// need to create this blank template file 'dashboard-notes.php' to enable MM to appear in the admin menu (view-access issues)
		$path = $this->wire('config')->paths->templates . 'dashboard-notes.php';
		if(!is_file($path)) {
			$notice = "<?php namespace ProcessWire;\n\n#### - Intentionally left blank. Please do not delete this file - ###";
			$notesTemplateFile = fopen($path, 'a');
			fwrite($notesTemplateFile, $notice);
			fclose($notesTemplateFile);
		}*/

		// add some extra settings ('allowed templates for children' doesn't seem to work with setImportData()? so we do it ourselves)
		return $this->extraTemplateSettings();

	}

	/**
	 * Add extra settings for the 4 dashboard-specific templates.
	 *
	 * @access private
	 * @return $this->createPages().
	 *
	 */
	private function extraTemplateSettings() {
		// 4. ###### post-creating our templates: additional settings for the child and parent notes templates ######

		$allowedChildTemplate = $this->wire('templates')->get("dashboard-note");
		$pt = $this->wire('templates')->get('dashboard-notes');

		// allowed child template for template 'dashboard-notes'
		$pt->childTemplates = array($allowedChildTemplate->id);// needs to be added as array of template IDs
		$pt->save();

		// allowed parent template for individual notes template
		// @note: this should work at JSON level but it's not, so doing it here as well
		$allowedChildTemplate->parentTemplates = array($pt->id);// needs to be added as array of template IDs
		$allowedChildTemplate->save();

		return $this->createPages();

	}

	/**
	 * Return JSON data for installing fields for the module.
	 *
	 * @access private
	 * @return string $fieldsJSON JSON string containing fields data for use with Field::setImportData().
	 *
	 */
	private function getFieldData() {
		$fieldsJSON = file_get_contents(__DIR__ . "/configs/fields.json");
		return json_decode($fieldsJSON, true);
	}

	/**
	 * Return JSON data for installing templates for the module.
	 *
	 * @access private
	 * @return string $templatesJSON JSON string containing templates data for use with Template::setImportData().
	 *
	 */
	private function getTemplateData() {
		$templatesJSON = file_get_contents(__DIR__ . "/configs/templates.json");
		return json_decode($templatesJSON, true);
	}

	/**
	 * Create notes parent page.
	 *
	 *
	 * @access private
	 *
	 */
	private function createPages() {

		// 5. ###### Create the 1 parent dashboard notes page

		$a = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$parent = $a->child('name=dashboard-notes');
		$template = $this->wire('templates')->get('dashboard-notes');

		// create the child page of 'Dashboard Notes': This is the parent page of all notes pages!
		$p = new Page();
		$p->template = $template;
		$p->parent = $parent;
		$p->title = "Notes";
		// @note: saving as hidden; we don't want to show in AdminThemeReno side menu
		$p->addStatus(Page::statusHidden);
		$p->save();

	}


}
