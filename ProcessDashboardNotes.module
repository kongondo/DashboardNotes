<?php namespace ProcessWire;

/**
* Process Dashboard Notes Module for ProcessWire
* This module enables developers to post messages in the ProcessWire Admin for remote collaboration and development support.
* Messages can be classed according to priority, access-controlled, threaded into conversations and expired.
*
* @author Francis Otieno (Kongondo)
*
* https://github.com/kongondo/ProcessDashboardNotes
* Created 24 February 2019
*
* ProcessWire 3.x
* Copyright (C) 2016 by Ryan Cramer
*
* Licensed under MIT v2, see LICENSE.TXT
*
* http://www.processwire.com
*
*/

class ProcessDashboardNotes extends Process implements Module {

	/**
	 * Return information about this module (required)
	 *
	 * @access public
	 *
	 */
	public static function getModuleInfo() {

		// @User role needs 'dashboard-notes' permission
		// @$permission = 'dashboard-notes';
		// @Installs MarkupMenuBuilder

		return array(
			'title' => 'Dashboard Notes: Process',
			'summary' => 'Create messages in ProcessWire Admin',
			'author' => 'Francis Otieno (Kongondo)',
			'version' => 1,
			'href' => 'http:// processwire.com/talk/topic/xxxx/',// @todo
			'singular' => true,
			'autoload' => false,
			'permission' => 'dashboard-notes',
			'requires' => 'FieldtypeComments'
		);

	}


	const PAGE_NAME = 'dashboard-notes';

	// @todo: delete as appropriate!

	/**
	 * Property to return this module's admin page (parent of all menus).
	 *
	 */
	protected $dashboardNotesParent;

	/**
	 * Property to store include children setting (boolean).
	 *
	 */
	private $includeChildren;

	/**
	 * Property to store disable items setting (boolean).
	 *
	 */
	private $disableItems;

	/**
	 * string name of the cookie used to save limit of posts to show per page in posts dashboard.
	 *
	 */
	private $cookieName;

	/**
	 * int value of number of posts/categories/tags to show per page respective dashboard page.
	 *
	 */
	private $showLimit;


	// other single menu properties
	private $menuItems;
	private $menuPages;
	private $dashboardNotesSettings;

	// multilingual
	private $menuItemsLanguages;

	private $noteTitle;
	private $noteText;
	private $notePriority;
	private $noteColour;
	private $noteReply;
	private $noteVisibilityLimit;
	private $noteLimitIDs;


	/**
	 * Initialise the module. This is an optional initialisation method called before any execute methods.
	 *
	 * Initialises various class properties ready for use throughout the class.
	 *
	 * @access public
	 *
	 */
	public function init() {

		// @todo: delete when done!

		/*
		$page = $this->wire('pages')->get(1297);
		$user = $this->wire('user');

		$c = new Comment();
		$c->text = 'Can anyone tell me what day it is please? I just gotta know.';
		$c->cite = $user->get('title|name');
		$c->email = $user->email;// do we need this?
		//$c->website = '';
		//$c->stars = 78;
		//$c->upvotes = 41;
		//$c->downvotes = 3;
		//$c->parent_id = 165; // or another comment's id
		//$c->parent_id = 0; // or another comment's id
		//$c->status = Comment::statusApproved;
		//$c->status = 1;
		// $c->ip = '127.0.0.1';
		// $c->user_agent = 'Chrome';
		$c->created_users_id = $user->id;

		$page->of(false);
		$page->dashboard_note->add($c);
		//$page->save('dashboard_note');
		$page->of(true);
		exit;*/

		$user = $this->wire('user');

		if ($this->wire('permissions')->get('dashboard-notes')->id && !$user->hasPermission('dashboard-notes'))
			 throw new WirePermissionException("You have no permission to use this module");

		$sanitizer = $this->wire('sanitizer');
		$urlSeg =  $sanitizer->pageName($this->wire('input')->urlSegment1);
		// add color picker
		if('edit' == $urlSeg) {
			$this->setNoteValues();
			$this->scriptConfigurations();
			$config = $this->wire('config');
			$url = $config->urls->ProcessDashboardNotes;
			$config->styles->add($url . "vendor/pickr/pickr.min.css");
			$config->scripts->add($url . "vendor/pickr/pickr.min.js");
		}

		$modules = $this->wire('modules');
		$modules->get("Jquery");
		$ui = $modules->get("JqueryUI");
		$ui->use("modal");
		// @todo; needed? if not, delete!
		$modules->get("JqueryMagnific");



		// @todo; delete when done! not needed
		$this->dashboardNotesParent = $this->wire('page');

		// @todo; delete when done! not needed
		// cookie per user to save state of number of menus to display per pagination screen in execute()
		$this->cookieName = $user->id . '-dashboardnotes';

		// @todo; delete when done! not needed?
		// default number of menus to show in dashboard notes landing page if no custom limit set (via post/session cookie).
		$this->showLimit = 10;

		parent::init();

	}

	/* ######################### - CONFIGS - ######################### */

	/**
	 * Outputs javascript configuration values for this module.
	 *
	 * @access protected
	 * @return string $scripts.
	 *
	 */
	protected function scriptConfigurations() {

		// translatable strings for use in JS
		$colourPickerSave = $this->_('Save');
		$colourPickerClear = $this->_('Clear');
		$noteColour = 0 === $this->noteColour ? $this->noteColour : "rgba({$this->noteColour})";

		// options for ajax calls
		$options = array('config' =>
			array(
				'colourPickerDefaultColour' => $noteColour,
				'colourPickerSave' => $colourPickerSave,
				'colourPickerClear' => $colourPickerClear,
			)
		);

		$scripts = $this->wire('config')->js($this->className(), $options);

		return $scripts;

	}

	/* ######################### - VIEWS - ######################### */

	/**
	 * Displays a list of the menus.
	 *
	 * This function is executed when a menu with Dashboard Notes Process assigned is accessed.
	 *
	 * @access public
	 * @return string $form Form markup.
	 *
	 */
	public function ___execute() {

		$out = '';

		// @todo: delete when done
		$id = "&id=1297";
		$id = "";

		$baseURL = $this->wire('config')->urls->admin . "dashboard-notes";
		$addURL = $baseURL . "/edit/?modal=1{$id}";
		$settingsURL = $baseURL . "/settings/";

		$addNoteText = $this->_('Add note');
		$allNoteSettingsText = $this->_('Settings');

		$out .=
			 "<div>" .
				"<ul>" .
					"<li><a href='{$addURL}' class='pw-modal pw-modal-medium'><span>{$addNoteText}</span></a></li>" .
					"<li><a href='{$settingsURL}'><span>{$allNoteSettingsText}</span></a></li>" .
				"</ul>" .

			"</div>";

		return $out;

		$modules = $this->wire('modules');
		$post = $this->wire('input')->post;

		// CREATE A NEW FORM
		$form = $modules->get('InputfieldForm');
		$form->attr('id', 'dashboard-notes');
		$form->action = './';
		$form->method = 'post';

		// CREATE A NEW WRAPPER
		$w = new InputfieldWrapper;

		// quick create menu markup
		$w->add($this->buildQuickCreateMenuMarkup());
		// menus table/list markup
		$w->add($this->buildMenusTableMarkup());
		// actions markup
		if ($this->menusTotal !=0) $w->add($this->buildMenusActionsMarkup());

		// add to form for rendering
		$form->add($w);

		// send input->post values to the Method save();
		if($post->menus_action_btn || $post->menu_new_unpublished_btn || $post->menu_new_published_btn) $this->save($form);

		// render the final form
		return $form->render();

	}

	/**
	 * Renders a single menu for editing. @todo
	 *
	 * Called when the URL is Menu Builders page URL + "/edit/"
	 * note: matches what is appended after ___execute below.
	 *
	 * @access public
	 * @return string $form Form markup.
	 *
	 */
	public function ___executeEdit() {

		// @TODO: MODIFY THIS TO CATER FOR EDIT VERSUS ADD NOTE! WE MIGHT WANT TO EDIT NOTE, E.G. TO CHANGE PRIORITY! WE SHOULD ALSO BE ABLE TO EDIT THE FIRST COMMENT! THIS MEANS WE'LL NEED TO SET attr('value', $value) to our inputs!

		// @Todo: maybe move to init! or construct? coz we need to set js configs as well! so move there and use class properties instead

		// @todo: reject save if no title or no text! and redirect to where we were.

		// @todo: title change hidden input!


		$modules = $this->wire('modules');

		// create form for adding new note (page)
		$form = $modules->get('InputfieldForm');
		$form->attr('id', 'dn_edit_note');
		$form->action = './';
		$form->method = 'post';
		$form->description = $this->noteTitle ? '' : $this->_('New Note');

		// note: old/current name (hidden input) @note: helps to determine if note title is changing + checks for duplication
		$f = $modules->get('InputfieldHidden');
		$f->attr('name', 'dn_edit_note_name');
		$f->attr('value', $this->noteTitle);

		$form->add($f);

		// new note: title (text)
		$f = $modules->get('InputfieldText');
		$f->attr('name', 'dn_note_title');
		$f->attr('value', $this->noteTitle);
		$f->description = $this->_('A title is required.');
		$f->label = $this->_('Title');
		$f->required = true;

		$form->add($f);

		// new note: inputfield textarea
		$f = $modules->get('InputfieldTextarea');
		$f->attr('name', 'dn_note_text');
		$f->attr('value', $this->noteText);
		$f->label = $this->_('Text');// @todo: change label?
		$f->description = $this->_('Contents of your note. This is required.');
		$f->required = true;
		$f->rows = 5;

		$form->add($f);


		######## SETTINGS #######

		$fieldset = $modules->get('InputfieldFieldset');
		$fieldset->attr('id', 'dn_note_settings');
		$fieldset->label = $this->_('Settings');
		$fieldset->collapsed = Inputfield::collapsedYes;

		/* ## note priority ## */
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_priority');
		$f->attr('value', $this->notePriority);
		$f->label =  $this->_('Priority');
		$f->notes = $this->_('Specify note priority/urgency.');

		// @todo: in render, use icons for priority?! otherwise, can clash with colours below which may be used to denote other things!

		$radioOptions = array (
			1 => $this->_('Low'),
			2 => $this->_('Normal'),
			3 => $this->_('High'),
		 );

		$f->addOptions($radioOptions);

		$fieldset->add($f);

		/* ## note background colour ## */
		$colourMarkup = "<div id='dn_colour_picker'></div>";
		$f = $modules->get('InputfieldMarkup');
		$f->attr('value', $colourMarkup);
		$f->label = $this->_('Colour');
		$f->notes = $this->_('Pick a background colour for the note. Default is no background colour');

		$fieldset->add($f);

		// hidden input to store selected/set note background colour. a value of 0 means no colour set.
		$f = $modules->get('InputfieldHidden');
		$f->attr('id+name', 'dn_note_colour');
		$f->attr('value', $this->noteColour);// @todo: rgb?
		$fieldset->add($f);

		/* ## note replies ## */
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_allow_replies');
		$f->attr('value', $this->noteReply);
		$f->label =  $this->_('Allow Replies');
		$f->notes = $this->_('Specify if others can reply to this note.');

		// @todo: in render, use icons for priority?! otherwise, can clash with colours below which may be used to denote other things!

		$radioOptions = array (
			1 => $this->_('Yes'),
			2 => $this->_('No'),
		);

		$f->addOptions($radioOptions);

		$fieldset->add($f);

		/* ## note visibility ## */
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_visibility_limit');
		$f->attr('value', $this->noteVisibilityLimit);
		$f->label =  $this->_('Visibility');
		//$f->collapsed = Inputfield::collapsedYes;
		$f->notes = $this->_('Specify who should be able to view this note. You can limit by roles, permissions or users. Otherwise, the note will be visible to all who can access Dashboard Notes.');

		$radioOptions = array (
			1 => $this->_('Visible to all with Dashboard Notes Access'),
			2 => $this->_('Roles'),
			3 => $this->_('Permissions'),
			4 => $this->_('Users'),
	 	);

		$f->addOptions($radioOptions);

		$fieldset->add($f);

		// @todo: move to function + show if!

		// note visibility: by role
		$f = $modules->get('InputfieldAsmSelect');
		$f->attr('name', "dn_note_limit_role");
		$f->attr('value', (2 == $this->noteVisibilityLimit ? $this->noteLimitIDs : array()));
		$f->label = $this->_('Roles Limit');
		$f->description = $this->_("Select roles allowed to view this note.");
		$f->showIf = 'dn_note_visibility_limit=2';
		$f->requiredIf = 'dn_note_visibility_limit=2';

		$roles = $this->getRoles();

		$f->addOptions($roles);

		$fieldset->add($f);

		// note visibility: by permission
		$f = $modules->get('InputfieldAsmSelect');
		$f->attr('name', "dn_note_limit_permission");
		$f->attr('value', (3 == $this->noteVisibilityLimit ? $this->noteLimitIDs : array()));
		$f->label = $this->_('Permissions Limit');
		$f->description = $this->_("Select permissions allowed to view this note.");
		$f->showIf = 'dn_note_visibility_limit=3';
		$f->requiredIf = 'dn_note_visibility_limit=3';

		$permissions = $this->getPermissions();

		$f->addOptions($permissions);

		$fieldset->add($f);

		// note visibility: by permission
		$f = $modules->get('InputfieldAsmSelect');
		$f->attr('name', "dn_note_limit_users");
		$f->attr('value', (4 == $this->noteVisibilityLimit ? $this->noteLimitIDs : array()));
		$f->label = $this->_('Users Limit');
		$f->description = $this->_("Select users who can view this note.");
		$f->showIf = 'dn_note_visibility_limit=4';
		$f->requiredIf = 'dn_note_visibility_limit=4';

		$users = $this->getUsers();

		$f->addOptions($users);

		$fieldset->add($f);

		########

		$form->add($fieldset);

		// new note: submit button
		$f = $modules->get('InputfieldButton');
		$f->attr('id+name', 'dn_note_edit_btn');
		$f->value = $this->_('Save');
		$f->attr('type', 'submit');

		$form->add($f);



		// post new note for saving
		$post = $this->wire('input')->post;
		if($post->dn_note_edit_btn){
			// @todo: saving here!

			// @todo: session redirect to saved new or edited note!
			$this->save($form);

		}

		return $form->render();

	}

	/**
	 * Renders a single menu for editing. @todo
	 *
	 * Called when the URL is Menu Builders page URL + "/edit/"
	 * note: matches what is appended after ___execute below.
	 *
	 * @access public
	 * @return string $form Form markup.
	 *
	 */
	public function ___executeSettings() {

		// @todo: maybe a default colour for notes as a setting as well?

		$dashboardNotesURL = $this->wire('config')->urls->admin . "dashboard-notes/";

		$backlinkText = $this->_('Back to all Notes. Add back icon here');

		$out =
			 "<div>" .
				"<a href='{$dashboardNotesURL}'><span>{$backlinkText}</span></a>" .
			"</div>";

		$out .= "<div>Settings for all notes. Backlink to all notes</div>";
		return $out;


		$modules = $this->wire('modules');
		$post = $this->input->post;

		// get the menu (page) we are editing
		$menuID = (int) $this->wire('input')->get->id;
		$menu = $this->wire('pages')->get("id=$menuID, parent=$this->dashboardNotesParent, include=all");// only get menu pages!

		$form = $modules->get('InputfieldForm');

		// if we found a valid menu page
		if($menu->id) {

			// menu settings
			$this->dashboardNotesSettings = $menu->dashboard_notes_settings ? json_decode($menu->dashboard_notes_settings, true) : array();
			// fetch this menu's JSON string with menu pages properties (pages find selector and inputfield to use)
			$this->menuPages = $menu->menu_pages ? json_decode($menu->menu_pages, true) : array();
			// fetch this menu's JSON string with menu items properties
			$this->menuItems = $menu->menu_items ? json_decode($menu->menu_items, true) : array();
			// if multilingual, active MB languages
			$this->menuItemsLanguages = isset($this->menuPages['menu_items_languages']) ? $this->menuPages['menu_items_languages'] : null;

			##############################

			$this->nestedSortableConfigs();
			$this->menuConfigs();// @note: we check if user has right permission in the method itself

			// check if menu is published or not
			$menu->is(Page::statusUnpublished) ? $pubStatus = 1 : $pubStatus = '';

			// check if menu is locked for editing
			$menu->is(Page::statusLocked) ? $editStatus = 1 : $editStatus = '';

			$editStatusNote = $editStatus ? $this->_(' (locked)') : '';

			// add a breadcrumb that returns to our main page @todo - don't show non-superadmins breadcrumbs?
			$this->breadcrumbs->add(new Breadcrumb('../', $this->wire('page')->title));
			$this->headline(sprintf(__('Edit menu: %s'), $menu->title) . $editStatusNote); // headline when editing a menu

			$form->attr('id', 'MenuBuilderEdit');
			$form->action = './';
			$form->method = 'post';

			############################################ - prep for tabs - ############################################

			$menuPages = $this->menuPages;

			// set include children + disable items status + for users with right permission
			if(count($menuPages)) {
				// enable include children feature
				if(isset($menuPages['children']) && $this->wire('user')->hasPermission('dashboard-notes-include-children')) {
					$this->includeChildren = $menuPages['children'];
				}
				// enable 'enable/disable' items feature
				if(isset($menuPages['disable_items']) && $this->wire('user')->hasPermission('dashboard-notes-disable-items')) {
					$this->disableItems = $menuPages['disable_items'];
				}
			}

			/***************** Add input buttons to Fourth tab *****************/

			$m = $modules->get('InputfieldHidden');
			$m->attr('name', 'menu_id');
			$m->attr('value', $menuID);
			$form->add($m);

			$m = $modules->get('InputfieldSubmit');
			$m->class .= ' head_button_clone';
			$m->attr('id+name', 'menu_save');
			$m->class .= " menu_save";// add a custom class to this submit button
			$m->attr('value', $this->_('Save'));
			$form->add($m);

			$m = $modules->get('InputfieldSubmit');
			$m->attr('id+name', 'menu_save_exit');
			$m->class .= " ui-priority-secondary";
			$m->class .= " menu_save";// add a custom class to this submit button
			$m->attr('value', $this->_('Save & Exit'));
			$form->add($m);

			return $form->render();

		}// end if $menu


		############################################ - if input->post - ############################################

		// if saving menu
		elseif($post->menu_save || $post->menu_save_exit || $post->note_delete) $this->save($form);
		// else invalid menu ID or no ID provided (e.g. /edit/)
		else $this->wire('session')->redirect($this->wire('page')->url);// redirect to landing page

	}


	/* ######################### - RENDER/MARKUP - ######################### */


	/**
	 * Recursively render list of threaded comments.
	 *
	 * @param integer $parent At which point of the hierarchy to start rendering from
	 * @param CommentArray $comments Array of comments.
	 * @param integer $first Helper parameter to know if on first list item.
	 * @return string $out Markup of threaded comments.
	 *
	 */
	private function renderThreadedComments($comments, $parent = 0, $first = 0) {

        $out = '';
		$replyText = $this->_('Reply');
		$hasChild = false;

        foreach ($comments as $comment) {

            // @todo: sort out \n and \t? not really important here though!

            // grab the comment text and clean it
            $commentText = htmlentities($comment->text, ENT_QUOTES, "UTF-8");
            $commentText = str_replace("\n\n", "</p><p>", $commentText);
            $commentText = str_replace("\n", "<br />", $commentText);

            $created = $comment->created;
            $commentDate = date( "d M Y", $created);// @todo: get from overall settings!

            ## - build nested comments - ##

            // if this comment item is a parent; create the inner-items/child-comment-items
            if ($comment->parent_id == $parent) {
                // if this is the first child
                if ($hasChild === false) {
                    $hasChild = true;// This is a parent
                    if ($first == 0){
                        $out .= "<ul id='dn_threaded_comments_main' class='uk-comment-list'>";
                        $first = 1;
                    }
                    else $out .= "<ul class='uk-comment-list'>";
                }

                $out .=
                    "<li>" .
                        "<article class='uk-comment'>" .
                            "<header class='uk-comment-header'>" .
                                "<h4 class='uk-comment-title'>{$comment->cite}</h4>" .
                                "<div class='uk-comment-meta'>{$commentDate}</div>" .
                            "</header>" .
                            "<div class='uk-comment-body uk-text-small'>{$commentText}</div>" .

                            // @todo: amend this! No need for some of the stuff here? Do we need the line?
                            "<div class='dn_note_comment_footer uk-margin-small-top uk-text-small'>" .
                            "<p class='dn_note_comment_action uk-margin-small'>" .
                                "<a class='dn_note_comment_action_reply' data-comment-id='{$comment->id}' href='#'>" .
                                    $replyText .
                                    "<span uk-icon='icon: arrow-right' class='uk-icon'>" .
                                        "<svg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'>
                                            <polyline fill='none' stroke='#000' points='10 5 15 9.5 10 14'></polyline>
                                            <line fill='none' stroke='#000' x1='4' y1='9.5' x2='15' y2='9.5'></line>
                                        </svg>" .
                                    "</span>" .
                                "</a>" .
                            "</p>" .
                        "</article>" .
                ######################### generate child-comment items [recursion] #########################
                $out .= $this->renderThreadedComments($comments, $comment->id, $first);
                // close the <li>
                $out .= "</li>";
            }// end if parent

        }// end foreach $comments

        if ($hasChild === true) $out .= "</ul>";

        return $out;

    }



	/* ######################### - CRUD ACTIONS - ######################### */

	/**
	 * Processes ProcessDashboardNotes form inputs (CRUD).
	 *
	 * CRUD - Processes all the form input sent from execute() and executeEdit().
	 *
	 * @access private
	 * @param object $form Sent form values.
	 *
	 */
	private function save($form) {

		$post = $this->wire('input')->post;

		// process form
		$form->processInput($post);


		// save new note or edit existing note
		if ($post->dn_note_edit_btn)$this->saveNote($post);
		// notes bulk actions: lock/unlock, trash/delete, change priority, allow replies
		elseif($post->dn_note_actions_btn) $this->bulkActionsNote($post);
		// save: note replies
		elseif($post->dn_note_reply || $post->dn_note_reply_btn) $this->saveNoteReply($post);
		// save: note settings
		elseif ($post->dn_note_settings_btn) $this->saveSettings($post);

	}

	/**
	 * Delete a single menu item. @todo: bulk trash those marked for trash? I think so!
	 *
	 * @access private
	 * @param integer $menuID ID of the Menu to delete.
	 *
	 */
	private function noteDelete($menuID) {

		if($menuID) {

			$page = $this->wire('page');
			$pages = $this->wire('pages');

			// if user does not have permission to trash/delete a menu, exit with an error
			if ($this->wire('permissions')->get('dashboard-notes-delete')->id && !$this->wire('user')->hasPermission('dashboard-notes-delete')) {
				$this->error($this->_('Dashboard Notes: You have no permission to delete menus.'));
				$this->session->redirect($page->url. 'edit/?id=' . $menuID);// redirect back to the menu we were editing
			}

			$menu = $pages->get("id=$menuID, parent=$this->dashboardNotesParent, include=all");

			// if menu is locked for editing, exit with an error
			if($menu->is(Page::statusLocked)) {
				$this->error($this->_('Dashboard Notes: This menu is locked for edits.'));
				$this->session->redirect($page->url. 'edit/?id=' . $menuID);// redirect back to the menu we were editing
			}

			if($pages->trash($menu)) {
				// also delete cache of menu if present
				$this->deleteMenuCache($menu->id);
				$this->message(sprintf($this->_('Dashboard Notes: Moved menu %1$s to trash: %2$s'), $menu->title, $menu->url));// tell user menu trashed
				$this->session->redirect($page->url);
			}

			else {
				$this->error($this->_('Dashboard Notes: Unable to move menu to trash'));// menu can't be moved to the trash error
				return false;
			}

		}

	}


	/**
	 * Save new menus.
	 *
	 * @access private
	 * @param array $post Input Post with new menus to save.
	 * @access private
	 *
	 */
	private function saveNewMenu($post) {

		$sanitizer = $this->wire('sanitizer');
		$addMenus = $post->menus_add_text;// $addMenus will be a string of text separated by a new line (\n).
		$newUnpublishedBtn = $post->menu_new_unpublished_btn;

		if ($addMenus) {

			$failed = array();
			$menus = explode("\n", $addMenus);// convert to an array

			// Sanitize and save new menus

			$i = 0;// set counter for number of menus added
			foreach ($menus as $m) {
				$p = new Page();
				$p->parent = $this->dashboardNotesParent;
				$p->template = $this->wire('templates')->get("menus");
				$p->title = $sanitizer->text($m);
				if (!$p->title) continue;// skip to next if no title provided
				if ($p->title) $p->name = $sanitizer->pageName($p->title);// sanitize and convert to a URL friendly page name

				// check if name already taken
				if($p->parent->child("name={$p->name}, include=all")->id) {
					// if the name already exists, add it to the $failed array [to display to user in error message later] and skip to next title
					$failed [] = $p->title;
					continue;
				}

				// if user pressed 'save unpublished', we save new menus unpublished
				if ($newUnpublishedBtn) $p->addStatus(Page::statusUnpublished);
				$p->save();
				$i++;

			}// end foreach $menus as $m

			// create a string of "failed" menu titles to add to error message
			$failedTitles = implode(', ', $failed);

			if($i > 0) $this->message(sprintf(_n("Added %d new menu.", "Added %d new menus.", $i), $i));// tell user how many menus were added
			if($failedTitles) $this->error($this->_("Some menus not added because names already in use. These are: {$failedTitles}."));
			$this->session->redirect($this->wire('page')->url);// redirect to landing page

		}// end if $addMenus

		// show error message if add button clicked without first entering some categories to add
		else $this->error($this->_("Dashboard Notes: You need to add some menus."));

	}

	/* ######################### - GETTERS - ######################### */

	/**
	 * Get all roles (minus guest) for selection for note visibility.
	 *
	 * @access private
	 * @return void
	 *
	 */
	private function getRoles() {
		$roles = array();
		foreach($this->wire('roles') as $role) {
			if($role->name == 'guest') continue;
			$roles[$role->id] = $role->name;
		}
		return $roles;
	}

	/**
	 * Get all permissions for selection for note visibility.
	 *
	 * @access private
	 * @return void
	 *
	 */
	private function getPermissions() {
		$permissions = array();
		foreach($this->wire('permissions') as $permission) {
			$permissions[$permission->id] = $permission->get("title|name");
		}
		return $permissions;
	}

	/**
	 * Get all users (minus guests) for selection for note visibility.
	 *
	 * @access private
	 * @return void
	 *
	 */
	private function getUsers() {
		$users = array();
		foreach($this->wire('users') as $user) {
			if(!$user->hasRole('superuser') && $user->hasRole('guest')) continue;
			$users[$user->id] = $user->name;
		}
		return $users;
	}

	/* ######################### - SETTERS - ######################### */

	/**
	 * Set class properties for adding versus editing a note.
	 *
	 * @access private
	 * @return void
	 *
	 */
	private function setNoteValues() {

		$notePageID = (int) $this->wire('input')->get->id;
		if($notePageID) {
			$page = $this->wire('pages')->get($notePageID);
			if($page) {
				$sanitizer = $this->wire('sanitizer');
				$this->noteTitle = $page->title;
				// ## settings ##
				$settingsArray = json_decode($page->dashboard_notes_settings, true);
				// text
				// @todo? no need for rich text, no?
				$this->noteText = $sanitizer->text($settingsArray['text']);
				// priority
				$this->notePriority = (int) $settingsArray['priority'];
				// background colour
				$this->noteColour = $sanitizer->text($settingsArray['colour']);
				// allow replies
				$this->noteReply = (int) $settingsArray['reply'];
				// visibility limit
				$this->noteVisibilityLimit = (int) $settingsArray['limit'];
				/// visibility limit by
				$this->noteLimitIDs = isset($settingsArray['limit_ids']) ? $settingsArray['limit_ids']  : array();
			}
		}

		else {
			$this->noteTitle = '';
			$this->noteText = '';
			$this->notePriority = 2;// 'normal'
			$this->noteColour = 0;
			$this->noteReply = 1;
			$this->noteVisibilityLimit = 1;// all who can view dashboard notes
			$this->noteLimitIDs = array();
		}

	}



	/* ######################### - INSTALLERS - ######################### */


	/**
	 * Called only when the module is installed.
	 *
	 * A new page with this Process module assigned is created.
	 * A new permission 'dashboard-notes' is created.
	 * 3 fields are created.
	 * A new template 'menu_pages' is created.
	 *
	 * @access public
	 *
	 */
	public function ___install() {

		// create ProcessDashboardNotes admin page and permission if verifyInstall() was successful in its validation
		if($this->verifyInstall($mode = null) == true) {
			$page = new Page();
			$page->template = 'admin';
			$page->parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
			$page->title = 'Dashboard Notes';
			$page->name = self::PAGE_NAME;
			$page->process = $this;
			#$page->addStatus(Page::statusHidden);
			$page->save();

			$this->verifyInstall($mode = 1);// run Dashboard Notes Installer

			// tell the user we created this page
			$this->message("Dashboard Notes: Created page {$page->path}");
		}

		else throw new WireException($this->_('Dashboard Notes: Installation aborted. Check and fix reported errors first.'));

		// create the permission 'dashboard-notes' and 'dashboard-notes-settings' to limit access to the module
		$perms = array(
			'dashboard-notes' => $this->_('Use Dashboard Notes'),
			// @todo?
			//'dashboard-notes-settings' => $this->_('Edit Dashboard Notes Settings'),
		);

		foreach ($perms as $k => $v) {
			$permission = $this->wire('permissions')->get($k);
			if (!$permission->id) {
				$p = new Permission();
				$p->name = $k;
				$p->title = $v;
				$p->save();
			}
		}

		// tell the user we created this module's permissions
		//$this->message('Dashboard Notes: Created new permissions dashboard-notes and dashboard-notes-settings.');
		$this->message('Dashboard Notes: Created new permission dashboard-notes.');

	}

	/**
	 * Called only when the module is uninstalled.
	 *
	 * This should return the site to the same state it was in before the module was installed.
	 * Deletes 3 fields, template and permission created on install as well as created menu pages.
	 *
	 * @access public
	 *
	 */
	public function ___uninstall() {

		$pages = $this->wire('pages');

		// find and delete the page we installed, locating it by the process field (which has the module ID)
		// it would probably be sufficient just to locate by name, but this is just to be extra sure.
		$moduleID = $this->wire('modules')->getModuleID($this);
		$dnPage = $pages->get("template=admin, process=$moduleID, name=" . self::PAGE_NAME);
		// $page = $pages->get('template=admin, name='.self::PAGE_NAME);

		if($dnPage->id) {
			// if we found the page, let the user know and delete it
			$this->message($this->_('Dashboard Notes: Deleted Page: ') . $dnPage->path);
			// recursively delete the dashboard notes page (i.e. including all its children (the note parent and its children the notes pages))
			$pages->delete($dnPage, true);
			// also delete any note pages that may have been left in the trash
			foreach ($pages->find('template=dashboard-note, status>=' . Page::statusTrash) as $p) $p->delete();
		}

		// find and delete the Dashboard Notes permissions and let the user know
		// @note: @todo: currently using only 1 permission!
		//$perms = array('dashboard-notes','dashboard-notes-settings');
		$perms = array('dashboard-notes');

		foreach ($perms as $p) {
			$permission = $this->wire('permissions')->get($p);
			if ($permission->id) $permission->delete();
		}

		// tell the user we created this module's permission
		// @note: @todo: currently using only 1 permission!
		//$this->message('Dashboard Notes: Deleted permissions dashboard-notes and dashboard-notes-settings.');
		$this->message('Dashboard Notes: Deleted permission dashboard-notes.');

		#############

		// find and delete the 2 templates used by our notes
		$templates = array('dashboard-note', 'dashboard-notes');
		foreach ($templates as $template) {
			$t = $this->wire('templates')->get($template);
			if($t->id) {
				$this->wire('templates')->delete($t);
				$this->wire('fieldgroups')->delete($t->fieldgroup);// delete the associated fieldgroups
			}
		}
		$this->message('Dashboard Notes: Deleted Templates dashboard-note and dashboard-notes');

		#############

		// find and delete the 2 fields used by our notes
		$fields = array('dashboard_note', 'dashboard_notes_settings');
		foreach ($fields as $field) {
			$f = $this->wire('fields')->get($field);
			if($f->id) $this->wire('fields')->delete($f);
		}
		$this->message('Dashboard Notes: Deleted Fields dashboard_note and dashboard_notes_settings');

	}

	/**
	 * Check if similar fields, templates and dashboard notes page exist before install.
	 *
	 * @access public
	 * @param null|integer $mode Whether to verify install possible (null) or commence install (1).
	 *
	 */
	public function verifyInstall($mode = null) {

		$pageCheck = '';

		// if we have already verified install, proceed directly to first step of installer
		if($mode == 1) return $this->createFields();

		// 1. ###### First we check if Dashboard Notes Admin page, fields and templates already exist.
		// If yes to any of these, we abort installation and return error messages

		// check if Dashboard Notes page already exists in Admin
		$parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$page = $this->wire('pages')->get("parent=$parent, template=admin, include=all, name=".self::PAGE_NAME);
		if($page->id && $page->id > 0) $pageCheck = $page->title;

		$pageExist = $pageCheck ? true : false;// we'll use this later + $pageCheck to show error

		// check if Dashboard Notes fields already exist
		$fields  = array('note' => 'dashboard_note','settings' => 'dashboard_notes_settings');

		$fieldsCheck = array();
		foreach ($fields as $key => $value) {if($this->wire('fields')->get($value))	$fieldsCheck [] = $this->wire('fields')->get($value)->name;}
		$fieldsExist = count($fieldsCheck) ? true : false;

		$templates = array('note' => 'dashboard-note','notes' => 'dashboard-notes');

		$templatesCheck = array();
		foreach ($templates as $template) {if($this->wire('templates')->get($template)) $templatesCheck [] = $this->wire('templates')->get($template)->name;}

		$templatesExist = count($templatesCheck) ? true : false;

		if($pageExist == true){
			$failedPage = $pageCheck;
			$this->error($this->_("Cannot install Dashboard Notes Admin page. A page named 'dashboard-notes' is already in use under Admin. Its title is: {$failedPage}."));
		}

		if($fieldsExist == true){
			$failedFields = implode(', ', $fieldsCheck);
			$this->error($this->_("Cannot install Dashboard Notes fields. Some field names already in use. These are: {$failedFields}."));
		}

		if($templatesExist == true){
			$failedTemplates = implode(', ', $templatesCheck);
			$this->error($this->_("Cannot install Dashboard Notes templates. Some template names already in use. These are: {$failedTemplates}."));
		}

		//if any of our checks returned true, we abort early
		if($pageExist == true || $fieldsExist == true || $templatesExist == true) {
			throw new WireException($this->_('Due to the above errors, Dashboard Notes did not install. Make necessary changes and try again.'));
			//due to above errors, we stop executing install of the following 'templates', 'fields' and 'pages'
		}

		// pass on to first step of install
		// return true to OK first step of install
		return true;

	}

	/**
	 * Create several Dashboard Notes fields.
	 *
	 * @note: We create from JSON using Field::setImportData().
	 *
	 * @access private
	 * @return $this->createTemplates().
	 *
	 */
	private function createFields() {

		// 2. ###### We create the fields we will need to add to our templates ######

		$fields = $this->getFieldData();
		$fieldNames = '';

		foreach ($fields as $fieldName => $fieldData) {
			$f = new Field();
			$f->setImportData($fieldData);
			$f->save();
			$fieldNames .= $fieldName . " ";
		}

		$this->message("Dashboard Notes: Created fields $fieldNames");

		// lets create some templates and add our fields to them
		return $this->createTemplates();

	}

	/**
	 * Create several Dashboard Notes templates.
	 *
	 * Create templates one each for the Dashboard Notes Notes parent and for individual Notes pages.
	 * @note: We create from JSON using Template::setImportData().
	 *
	 * @access private
	 * @return $this->extraTemplateSettings().
	 *
	 */
	private function createTemplates() {

		// 3. ###### We create the templates needed by Dashboard Notes ######

		$templates = $this->getTemplateData();
		$templateNames = '';

		foreach ($templates as $templateName => $templateData) {
			$fg = new Fieldgroup();
			$fg->name = $templateName;
			$templateNames .= $templateName . " ";
			foreach ($templateData['fieldgroupFields'] as $fieldname) $fg->add($fieldname);
			$fg->save();
			$t = new Template();
			$t->setImportData($templateData) ;
			$t->save();
		}

		$this->message("Dashboard Notes: Created templates $templateNames");

		/* @todo?
		// need to create this blank template file 'dashboard-notes.php' to enable MM to appear in the admin menu (view-access issues)
		$path = $this->wire('config')->paths->templates . 'dashboard-notes.php';
		if(!is_file($path)) {
			$notice = "<?php namespace ProcessWire;\n\n#### - Intentionally left blank. Please do not delete this file - ###";
			$notesTemplateFile = fopen($path, 'a');
			fwrite($notesTemplateFile, $notice);
			fclose($notesTemplateFile);
		}*/

		// add some extra settings ('allowed templates for children' doesn't seem to work with setImportData()? so we do it ourselves)
		return $this->extraTemplateSettings();

	}

	/**
	 * Add extra settings for the 4 dashboard-specific templates.
	 *
	 * @access private
	 * @return $this->createPages().
	 *
	 */
	private function extraTemplateSettings() {
		// 4. ###### post-creating our templates: additional settings for the child and parent notes templates ######

		$allowedChildTemplate = $this->wire('templates')->get("dashboard-note");
		$pt = $this->wire('templates')->get('dashboard-notes');

		// allowed child template for template 'dashboard-notes'
		$pt->childTemplates = array($allowedChildTemplate->id);// needs to be added as array of template IDs
		$pt->save();

		// allowed parent template for individual notes template
		// @note: this should work at JSON level but it's not, so doing it here as well
		$allowedChildTemplate->parentTemplates = array($pt->id);// needs to be added as array of template IDs
		$allowedChildTemplate->save();

		return $this->createPages();

	}

	/**
	 * Return JSON data for installing fields for the module.
	 *
	 * @access private
	 * @return string $fieldsJSON JSON string containing fields data for use with Field::setImportData().
	 *
	 */
	private function getFieldData() {
		$fieldsJSON = file_get_contents(__DIR__ . "/configs/fields.json");
		return json_decode($fieldsJSON, true);
	}

	/**
	 * Return JSON data for installing templates for the module.
	 *
	 * @access private
	 * @return string $templatesJSON JSON string containing templates data for use with Template::setImportData().
	 *
	 */
	private function getTemplateData() {
		$templatesJSON = file_get_contents(__DIR__ . "/configs/templates.json");
		return json_decode($templatesJSON, true);
	}

	/**
	 * Create notes parent page.
	 *
	 *
	 * @access private
	 *
	 */
	private function createPages() {

		// 5. ###### Create the 1 parent dashboard notes page

		$a = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$parent = $a->child('name=dashboard-notes');
		$template = $this->wire('templates')->get('dashboard-notes');

		// create the child page of 'Dashboard Notes': This is the parent page of all notes pages!
		$p = new Page();
		$p->template = $template;
		$p->parent = $parent;
		$p->title = "Notes";
		// @note: saving as hidden; we don't want to show in AdminThemeReno side menu
		$p->addStatus(Page::statusHidden);
		$p->save();

	}


}
