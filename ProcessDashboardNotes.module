<?php namespace ProcessWire;

/**
* Process Dashboard Notes Module for ProcessWire
* This module enables developers to post messages in the ProcessWire Admin for remote collaboration and development support.
* Messages can be classed according to priority, access-controlled, threaded into conversations and expired.
*
* @author Francis Otieno (Kongondo)
*
* https://github.com/kongondo/ProcessDashboardNotes
* Created 24 February 2019
*
* ProcessWire 3.x
* Copyright (C) 2016 by Ryan Cramer
*
* Licensed under MIT v2, see LICENSE.TXT
*
* http://www.processwire.com
*
*/

class ProcessDashboardNotes extends Process implements Module {

	/**
	 * Return information about this module (required)
	 *
	 * @access public
	 *
	 */
	public static function getModuleInfo() {

		// @User role needs 'dashboard-notes' permission
		// @$permission = 'dashboard-notes';
		// @Installs MarkupMenuBuilder

		return array(
			'title' => 'Dashboard Notes: Process',
			'summary' => 'Create messages in ProcessWire Admin',
			'author' => 'Francis Otieno (Kongondo)',
			'version' => 1,
			'href' => 'http:// processwire.com/talk/topic/xxxx/',// @todo
			'singular' => true,
			'autoload' => false,
			'permission' => 'dashboard-notes',
			'requires' => 'FieldtypeComments'
		);

	}


	const PAGE_NAME = 'dashboard-notes';

	/** class properties **/
	private $urlSeg1;// urlSegment1
	private $baseURL;// base URL to this module
	private $dateFormat;// for formatting note dates display
	private $pageNumStr;// for storing value of $input->pageNumStr() {pagination/page number}
	private $pageNumParamStr;// for url with page number param string affixed
	private $noSettings;// cannot view or save settings

	// @note: properties shared between single note and global settings! [for save of js scripts]
	private $noteTextColour;// notes background colour
	private $noteBackgroundColour;// notes background colour

	// for single note
	private $note;// @note: WireData() if new note, else Page
	// for notes global default settings
	private $settings;// WireData()


	/**
	 * Initialise the module. This is an optional initialisation method called before any execute methods.
	 *
	 * Initialises various class properties ready for use throughout the class.
	 *
	 * @access public
	 *
	 */
	public function init() {

		$user = $this->wire('user');
		$permissions = $this->wire('permissions');

		if ($permissions->get('dashboard-notes')->id && !$user->hasPermission('dashboard-notes'))
			 throw new WirePermissionException("You have no permission to use this module");

			 // check if user has permission to view and save settings
		$this->noSettings = $permissions->get('dashboard-notes-settings')->id && !$user->hasPermission('dashboard-notes-settings') ? true : false;

		// init class properties
		$this->settings = new WireData();
		$this->baseURL = $this->wire('config')->urls->admin . "dashboard-notes";

		$input = $this->wire('input');
		$sanitizer = $this->wire('sanitizer');
		$this->urlSeg1 =  $sanitizer->pageName($input->urlSegment1);

		# page number string
		// for paginated views leading to note edit or view. we use this to create backlink that leads to where in pagation user was
		// the param string is 'page' [e.g. &page=page4]
		$pageNumParamStr = $sanitizer->fieldName($input->page);
		$this->pageNumParamStr = $pageNumParamStr ? $pageNumParamStr : "";

		// for main dashboard, we use this to store $input->pageNum() so we can redirect properly after bulk action
		// this will be page3, etc.
		$this->pageNumStr = $input->pageNumStr();

		// prepare notes global settings @note: calling before setNoteValues()  so not to cancel shared colour properties with single note values!
		$this->setGlobalNoteValues();

		// date formats
		$dateFormats = array(1=>"d/m/Y", 2=>"Y/m/d",3=>"m/d/Y");
		$dateFormat = $dateFormats[$this->settings->dateFormat];
		// showing month label instead of digits
		if($this->settings->dateMonthLabel == 2) $dateFormat = str_replace(array("/","m"),array(" ","F"), $dateFormat);
		$this->dateFormat = $dateFormat;

		// initialise extra properties for a single note for viewing or editing
		if('edit' == $this->urlSeg1 || 'view' == $this->urlSeg1) {
			$this->setNoteValues();
		}

		// add color picker to new/edit and settings pages
		if('edit' == $this->urlSeg1 || 'settings' == $this->urlSeg1) {
			$this->scriptConfigurations();
			$config = $this->wire('config');
			$url = $config->urls->ProcessDashboardNotes;
			$config->styles->add($url . "vendor/pickr/pickr.min.css");
			$config->scripts->add($url . "vendor/pickr/pickr.min.js");
		}

		parent::init();

	}

	/* ######################### - CONFIGS - ######################### */

	/**
	 * Outputs javascript configuration values for this module.
	 *
	 * @access protected
	 * @return string $scripts.
	 *
	 */
	protected function scriptConfigurations() {

		// translatable strings for use in JS
		$colourPickerSave = $this->_('Set');
		$colourPickerClear = $this->_('Clear');
		$noteTextColour = 0 === $this->noteTextColour ? $this->noteTextColour : "rgba({$this->noteTextColour})";
		$noteBackgroundColour = 0 === $this->noteBackgroundColour ? $this->noteBackgroundColour : "rgba({$this->noteBackgroundColour})";

		// options for ajax calls
		$options = array('config' =>
			array(
				'colourPickerDefaultTextColour' => $noteTextColour,
				'colourPickerDefaultBackgroundColour' => $noteBackgroundColour,
				'colourPickerSave' => $colourPickerSave,
				'colourPickerClear' => $colourPickerClear,
			)
		);

		$scripts = $this->wire('config')->js($this->className(), $options);

		return $scripts;

	}

	/* ######################### - VIEWS - ######################### */

	/**
	 * Displays a list of the menus.
	 *
	 * This function is executed when a menu with Dashboard Notes Process assigned is accessed.
	 *
	 * @access public
	 * @return string $form Form markup.
	 *
	 */
	public function ___execute() {

		$out = '';
		$pgOut = '';// for pagination
		$modules = $this->wire('modules');
		// bulk actions
		$actions = array(
			'lock' => $this->_('Lock'),
			'unlock' => $this->_('Unlock'),
			'priority_low' => $this->_('Low Priority'),
			'priority_normal' => $this->_('Normal Priority'),
			'priority_high' => $this->_('High Priority'),
			'trash' => $this->_('Trash'),
			'delete' => $this->_('Delete'),
		);

		$notes = $this->getNotes();

		if($notes->count()) {
			$start = $notes->getStart();
			$limit = $notes->getLimit();
			$end = $start+$notes->count();
			$total = $notes->getTotal();
			$headline = sprintf(__('%1$d to %2$d of %3$d'), $start+1, $end, $total);
			if($total > $limit) {
				$pager = $modules->get('MarkupPagerNav');
				#Solution for pagination when using URL segments
				// get the url segment string.
				$url = $this->wire('page')->url . $this->wire('input')->urlSegmentsStr;
				$pgOut = $notes->renderPager(array('baseUrl' => $url));
			}
		}
		// either no notes for real, or redirected to a page (pagination) where no notes found due to deletion, etc
		// so redirect to first page
		elseif(strlen($this->pageNumStr)) $this->wire('session')->redirect($this->baseURL);
		// no notes for real
		else $headline = $this->_('No notes found. Add one to get started.');

		###############

		// create form for adding new note (page)
		$form = $modules->get('InputfieldForm');
		$form->attr('id', 'dn_notes_bulk');
		$form->action = './';
		$form->method = 'post';

		// select dropdown
		$label = '<label id="dn_action_select_label" for="dn_action_select">' . $this->_("Action") . '</label>';
		$f = $modules->get('InputfieldSelect');
		$f->attr('id+name', 'dn_action_select');
		$f->addOptions($actions);
		$actions = $f->render();


		// @note: our menu has two items only: "Notes" and "Settings". if user can see and edit settings, we show the menu
		if(!$this->noSettings) {
			$menu = "<div class='uk-width-expand uk-first-column'>" .$this->renderMenu() .	"</div>";
			$menuActionsClass = " uk-width-1-3@s";
		}
		// else, no need to have a one item menu
		else {
			$menu = "";
			$menuActionsClass = " uk-width-1-1@s";
		}

		$topPanel =
			"<div id='mm_top_panel' class='mm_top_panel'>" .
				"<div id='mm_menu_actions_wrapper' uk-grid class='uk-grid'>" .
					$menu .
					"<div id='mm_actions' class='mm_actions{$menuActionsClass}'>" .
						$actions .
						"<label id='dn_action_select_label' for='dn_action_select'>" . $this->_('Action') . "</label>" .
					"</div>" .
					"<div id='dn_create_new_note' class='mm_actions uk-width-1-1@s'>" . $this->renderCreateNote() . "</div>" .
				"</div>" .// div#dn_menu_actions_wrapper
			"</div>";// div#dn_top_panel

		// top pagination panel
		$topPaginationPanel =
			"<div id='top_pager'>" .
				"<h2 class='dn_results_headline'>{$headline}</h2>" .
				$pgOut .
			"</div>";


		// rendered notes
		$notesMarkup = "<div id='dn_notes_container'>" . $this->renderNotes($notes) . "</div>";

		// bottom pagination panel
		$bottomPaginationPanel = "<div id='bottom_pager'>{$pgOut}</div>";

		$finalMarkup = $topPanel . $topPaginationPanel . $notesMarkup . $bottomPaginationPanel . $this->renderShiftSelectMarkup();

		$f = $modules->get('InputfieldMarkup');
		$f->attr('value', $finalMarkup);

		$form->add($f);

		// hidden input to store param string for pagination. Helps with redirection after bulk action.
		$f = $modules->get('InputfieldHidden');
		$f->attr('id+name', 'dn_note_pagination_num');
		$f->attr('value', $this->pageNumStr);
		$form->add($f);

		// apply (save) button
		$f = $modules->get('InputfieldSubmit');
		$f->attr('id+name', 'dn_actions_btn');
		$f->icon = 'check-square-o';
		$f->showInHeader();
		$f->class .= ' dn_hide';
		$f->attr('value', $this->_('Apply'));
		$form->add($f);

		// post: saving all note settings
		$post = $this->wire('input')->post;
		if($post->dn_actions_btn) $this->save($form);

		$out .= $form->render();

		return $out;

	}

	/**
	 * Renders a note for viewing and responses if enabled.
	 *
	 *
	 * @access public
	 * @return string $form Form markup. @todo
	 *
	 */
	public function ___executeView() {

		$note = $this->note;

		// @access-control: user has no visibility access to this note
		if(!$this->checkAccess($this->note)) {
			$this->error($this->_('You have no access to this note!'));
			$this->wire('session')->redirect($this->baseURL);
		}

		$out = '';
		$editMarkup = '';
		if($this->checkEdit($note)) {
			$urlParamPageNumStr = $this->wire('input')->page ? "?page=" . $this->wire('input')->page : "";
			$editURL = $this->baseURL . "/edit/{$note->id}/{$urlParamPageNumStr}";
			$editClass = 'dn_back_to_edit';
			$editIcon = "<i class='fa fa-lg fa-pencil-square-o'></i>";
			$viewEditDividerMarkup = "<span class='dn_note_back_edit_divider'>&#47;</span>";
			$editMarkup = $viewEditDividerMarkup ."<a href='{$editURL}' class='{$editClass}'>" . $editIcon . "</a>";
		}

		$date = date($this->dateFormat, $note->created);// @todo: get from overall settings!
		// @todo; configurable field to get author name!
		$author = $note->createdUser->name;
		$this->headline($note->title);

		// for comments/responses to note
		// @note: if $this->settings->maxReply > 0, since we start by minusing 1, we add 1 to it. If $this->settings->maxReply == 0, we set it to infinity
		$depth = $this->settings->maxReply ? $this->settings->maxReply + 1 : INF;

		// asterisks @todo: use this or numbers 1 - 3?
		$notePriority = str_repeat("&#42;",$note->priority);
		$metaDivider = "&#47;";

		$out .=
			"<div id='dn_single_note'>" .
				"<a href='{$this->baseURL}/{$this->pageNumParamStr}' class='dn_back_to_all_notes'><i class='fa fa-fw fa-arrow-circle-left'></i>" . $this->_('Back to all notes') . "</a>" . $editMarkup .
				"<header class='uk-comment-header'>" .
					"<div class='uk-comment-meta'>{$date} {$metaDivider} {$author} {$metaDivider} {$notePriority}</div>".
				"</header>" .
				"<div id='dn_note_text'>{$note->text}</div>" .
				$this->renderReplyMarkup() .
			"</div>";

		return $out;

	}

	/**
	 * Renders a single note for editing. @todo
	 *
	 * Caters for both new and existing notes.
	 *
	 * @access public
	 * @return string $out Create/Edit note markup.
	 *
	 */
	public function ___executeEdit() {

		$note = $this->note;

		// @access-control: user has no visibility access to this note OR users not allowed to edit each other's notes and this user is not the note author
		$user = $this->wire('user');
		$editOther = $this->checkEdit($note);
		if((!$this->checkAccess($this->note)) || (!$editOther)) {
			$this->error($this->_('You have no access to this note!'));
			$this->wire('session')->redirect($this->baseURL);
		}

		$out = "";
		$modules = $this->wire('modules');
		$viewMarkup = '';
		$headline = $note->title ? $note->title : $this->_('Add New');
		$warningNoticeNoVisibilityIDsSet = $this->_('Please note that if nothing is selected here, irrespective of your visibility setting, all notes will be visible to everyone with access to Dashboard Notes!');

		if($note->title) {
			if(1 == $note->locked) $this->warning($this->_('This note is locked for edits. Unlock it first to edit.'));
			$headline = $note->title;
			$date = date($this->dateFormat, $note->created);
			// @todo; configurable field to get author name!?
			$author = $note->createdUser->name;
			// asterisks @todo: use this or numbers 1 - 3?
			$notePriority = str_repeat("&#42;",$note->priority);
			$metaDivider = "&#47;";
			$meta = "{$date} {$metaDivider} {$author} {$metaDivider} <span class='dn_note_priority_meta'>{$notePriority}</span>";

			// view markup link
			$urlParamPageNumStr = $this->wire('input')->page ? "?page=" . $this->wire('input')->page : "";
			$viewURL = $this->baseURL . "/view/{$note->id}/{$urlParamPageNumStr}";
			$viewClass = 'dn_back_to_edit';
			$viewIcon = "<i class='fa fa-lg fa-eye'></i>";
			$viewEditDividerMarkup = "<span class='dn_note_back_view_divider'>&#47;</span>";
			$viewMarkup = $viewEditDividerMarkup ."<a href='{$viewURL}' class='{$viewClass}'>" . $viewIcon . "</a>";

		}

		else {
			$headline = $this->_('Add New');
			$meta = '';
		}

		$this->headline($headline);

		// back to all notes should return you to page where you were unless pagination changed due to other reasons
		$out .=
			"<div id='dn_single_note'>" .
				"<a href='{$this->baseURL}/{$this->pageNumParamStr}' class='dn_back_to_all_notes'><i class='fa fa-fw fa-arrow-circle-left'></i>" . $this->_('Back to all notes') . "</a>" .
				$viewMarkup .
				"<header class='uk-comment-header'>" .
					"<div class='uk-comment-meta'>{$meta}</div>".
				"</header>" .
			"</div>";

		// create form for adding new note (page)
		$form = $modules->get('InputfieldForm');
		$form->attr('id', 'dn_note_edit');
		$form->action = './';
		$form->method = 'post';

		// note: page ID
		$f = $modules->get('InputfieldHidden');
		$f->attr('name', 'dn_note_page_id');
		$f->attr('value', (int) $note->id);

		$form->add($f);

		// note: old/current name (hidden input) @note: helps to determine if note title is changing + checks for duplication
		$f = $modules->get('InputfieldHidden');
		$f->attr('name', 'dn_note_edit_title');
		$f->attr('value', $note->title);

		$form->add($f);

		// new note: title (text)
		$f = $modules->get('InputfieldText');
		$f->attr('name', 'dn_note_title');
		$f->attr('value', $note->title);
		$f->description = $this->_('A title is required.');
		$f->label = $this->_('Title');
		$f->required = true;

		$form->add($f);

		// new note: inputfield textarea
		$f = $modules->get('InputfieldTextarea');
		$f->attr('name', 'dn_note_text');
		$f->attr('value', $note->text);
		$f->label = $this->_('Text');// @todo: change label?
		$f->description = $this->_('Contents of your note. This is required.');
		$f->required = true;
		$f->rows = 5;

		$form->add($f);


		######## SETTINGS #######

		$fieldset = $modules->get('InputfieldFieldset');
		$fieldset->attr('id', 'dn_note_settings');
		$fieldset->label = $this->_('Settings');
		// for new notes, do not collapse settings
		if($note->title) $fieldset->collapsed = Inputfield::collapsedYes;

		/* ## note priority ## */
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_priority');
		$f->attr('value', $note->priority);
		$f->label =  $this->_('Priority');
		$f->notes = $this->_('Specify note priority/urgency.');

		$radioOptions = array (
			1 => $this->_('Low'),
			2 => $this->_('Normal'),
			3 => $this->_('High'),
		 );

		$f->addOptions($radioOptions);

		$fieldset->add($f);

		/* ## notes text and background colours ## */
		$textColourLabel = $this->_('Text Colour');
		$textColourMarkup = "<div class='uk-width-1-2@s'><h4>{$textColourLabel}</h4><div id='dn_text_colour_picker' class='dn_colour_picker' data-colour='dn_note_text_colour' data-colour-type='text'></div></div>";

		$backgroundColourLabel = $this->_('Background Colour');
		$backgroundColourMarkup = "<div class='uk-width-1-2@s'><h4>{$backgroundColourLabel}</h4><div id='dn_background_colour_picker' class='dn_colour_picker' data-colour='dn_note_background_colour' data-colour-type='background'></div></div>";

		$coloursMarkup = "<div uk-grid class='uk-grid'>{$textColourMarkup}{$backgroundColourMarkup}</div>";

		$f = $modules->get('InputfieldMarkup');
		$f->attr('value', $coloursMarkup);
		$f->label = $this->_('Note Colours');
		$f->notes = $this->_('Pick text and background colours for this note. For the text, If none is picked, it will default to the current CSS text colour. For the background, the default is no background colour. Please note that if you have specified defaults colours in your global settings, those will be applied here if this is a new note. If you wish to override those, please select different colours for this note.');

		$fieldset->add($f);

		// hidden input to store selected/set note text colour. a value of 0 means no colour set.
		$f = $modules->get('InputfieldHidden');
		$f->attr('id+name', 'dn_note_text_colour');
		// @note: we only save the values (e.g. "12,45,23,1")
		// @note: for display and for JS configs we add the correct formatting rgba() around the values
		$f->attr('value', $note->textColour);
		$fieldset->add($f);

		// hidden input to store selected/set note background colour. a value of 0 means no colour set.
		$f = $modules->get('InputfieldHidden');
		$f->attr('id+name', 'dn_note_background_colour');
		// @note: we only save the values (e.g. "12,45,23,1")
		// @note: for display and for JS configs we add the correct formatting rgba() around the values
		$f->attr('value', $note->backgroundColour);
		$fieldset->add($f);

		/* ## note replies ## */
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_allow_replies');
		$f->attr('value', $note->reply);
		$f->label =  $this->_('Allow Replies');
		$f->notes = $this->_('Specify if others can reply to this note.');

		$radioOptions = array (
			1 => $this->_('Yes'),
			2 => $this->_('No'),
		);

		$f->addOptions($radioOptions);

		$fieldset->add($f);

		/* ## note locked for edits ## */
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_locked');
		$f->attr('value', $note->locked);
		$f->label =  $this->_('Lock');
		$f->notes = $this->_('Specify if this note is locked for edits. Locked notes cannot be edited or deleted.');

		$radioOptions = array (
			1 => $this->_('Yes'),
			2 => $this->_('No'),
		);

		$f->addOptions($radioOptions);

		$fieldset->add($f);

		/* ## note visibility ## */
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_visibility_limit');
		$f->attr('value', $note->limitVisibility);
		$f->label =  $this->_('Visibility');
		//$f->collapsed = Inputfield::collapsedYes;
		$f->notes = $this->_('Specify who should be able to view this note. You can limit by roles, permissions or users. Otherwise, the note will be visible to all who can access Dashboard Notes.');

		$radioOptions = array (
			1 => $this->_('Visible to all with Dashboard Notes Access'),
			2 => $this->_('Roles'),
			3 => $this->_('Permissions'),
			4 => $this->_('Users'),
		);

		$f->addOptions($radioOptions);

		$fieldset->add($f);

		// note visibility: by role (2)
		$f = $modules->get('InputfieldAsmSelect');
		$f->attr('name', "dn_note_limit_role");
		$f->attr('value', (2 == $note->limitVisibility ? $note->limitVisibilityIDs : array()));
		$f->label = $this->_('Roles Limit');
		$f->description = $this->_("Select roles allowed to view this note.");
		$f->showIf = 'dn_note_visibility_limit=2';
		$f->requiredIf = 'dn_note_visibility_limit=2';
		$f->notes = $warningNoticeNoVisibilityIDsSet;

		$roles = $this->getRoles();

		$f->addOptions($roles);

		$fieldset->add($f);

		// note visibility: by permission (3)
		$f = $modules->get('InputfieldAsmSelect');
		$f->attr('name', "dn_note_limit_permission");
		$f->attr('value', (3 == $note->limitVisibility ? $note->limitVisibilityIDs : array()));
		$f->label = $this->_('Permissions Limit');
		$f->description = $this->_("Select permissions allowed to view this note.");
		$f->showIf = 'dn_note_visibility_limit=3';
		$f->requiredIf = 'dn_note_visibility_limit=3';
		$f->notes = $warningNoticeNoVisibilityIDsSet;

		$permissions = $this->getPermissions();

		$f->addOptions($permissions);

		$fieldset->add($f);

		// note visibility: by permission (4)
		$f = $modules->get('InputfieldAsmSelect');
		$f->attr('name', "dn_note_limit_users");
		$f->attr('value', (4 == $note->limitVisibility ? $note->limitVisibilityIDs : array()));
		$f->label = $this->_('Users Limit');
		$f->description = $this->_("Select users who can view this note.");
		$f->showIf = 'dn_note_visibility_limit=4';
		$f->requiredIf = 'dn_note_visibility_limit=4';
		$f->notes = $warningNoticeNoVisibilityIDsSet;

		$users = $this->getUsers();

		$f->addOptions($users);

		$fieldset->add($f);

		// hidden input to store param string for pagination. Helps to set 'back to all notes' link correctly after save so user can head back to the last page (with this note) that they were browsing
		$f = $modules->get('InputfieldHidden');
		$f->attr('id+name', 'dn_note_pagination_num_str');
		$f->attr('value', $this->pageNumParamStr);
		$fieldset->add($f);

		$form->add($fieldset);

		########

		// new note: submit button
		$f = $modules->get('InputfieldSubmit');
		$f->attr('id+name', 'dn_note_edit_btn');
		$f->value = $this->_('Save');
		$f->showInHeader();

		$f = $this->wire('modules')->get('InputfieldSubmit');
		$f->attr('id+name', 'dn_note_edit_btn');
		$f->value = $this->_('Save');
		$f->showInHeader();

		/*
			@note:
			- pw will store their sent values in hidden input with id dn_note_edit_btn_dropdown_value
			- i.e. appends '_dropdown_value' to our submit button's id
			- its name is _action_value ($post->_action_value)
		*/
		$dropdownButtonOptions = array(
			// deactivate filter dropdown
			0 => array(
				'value' => 'exit',
				'label' => $this->_('Save + Exit'),
				'icon' => 'close'
			),
			// lock filter dropdown
			1 => array(
				'value' => 'new',
				'label' => $this->_('Save + Add New'),
				'icon' => 'plus-circle'
			),
			// unlock filter dropdown
			2 => array(
				'value' => 'view',
				'label' => $this->_('Save + View'),
				'icon' => 'eye'
			),
			// delete filter dropdown
			3 => array(
				'value' => 'next',
				'label' => $this->_('Save + Next'),
				'icon' => 'edit'
			)
		);

		foreach($dropdownButtonOptions as $key => $value) {
			$f->addActionValue(
				$value['value'],
				$value['label'],
				$value['icon']
			);
		}

		$form->add($f);

		// post: saving single new or edited note
		$post = $this->wire('input')->post;
		if($post->dn_note_edit_btn) $this->save($form);

		$out .= $form->render();

		return $out;

	}

	/**
	 * Renders global notes settings for editing. @todo
	 *
	 * @access public
	 * @return string $form Form markup.
	 *
	 */
	public function ___executeSettings() {

		// @todo: add setting to select field to show note author name rather than user name?
		// @todo: what about setting to show author image?

		// @access-control: user has not allowed to view or edit global note settings
		if($this->noSettings) $this->wire('session')->redirect($this->baseURL);

		$out = '';

		$out .=
			"<div id='dn_top_wrapper' uk-grid>" .
				"<div class='uk-width-expand'>" .
					$this->renderMenu() .
				"</div>" .
			"</div>";

		$modules = $this->wire('modules');

		// create form for all notes settings
		$form = $modules->get('InputfieldForm');
		$form->attr('id', 'dn_note_settings');
		$form->action = './';
		$form->method = 'post';

		/* ## notes date format ## */
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_date_format');
		$f->attr('value', $this->settings->dateFormat);
		$f->label =  $this->_('Date Format');
		$f->notes = $this->_('Display format for note created dates.');

		$day = $this->_('Day');
		$month = $this->_('Month');
		$year = $this->_('Year');

		$radioOptions = array (
			1 => "$day $month $year (30/04/2015)",
			2 => "$year $month $day (2015/04/30)",
			3 => "$month $day $year (04/30/2015)",
		);

		$f->addOptions($radioOptions);

		$form->add($f);

		/* ## notes date month label ## */
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_date_month_label');
		$f->attr('value', $this->settings->dateMonthLabel);
		$f->label =  $this->_('Date Month Label');
		$f->notes = $this->_('Specify if to show month name or number in notes\' dates.');

		$monthName = $this->_('Month Text');
		$monthNumber = $this->_('Month Digits');

		$radioOptions = array (
			1 => "$monthNumber (30/04/2015)",
			2 => "$monthName (30 April 2015)",
		);

		$f->addOptions($radioOptions);

		$form->add($f);

		/* ## notes default text and background colours ## */
		$textColourLabel = $this->_('Text Colour');
		$textColourMarkup = "<div class='uk-width-1-2@s'><h4>{$textColourLabel}</h4><div id='dn_text_colour_picker' class='dn_colour_picker' data-colour='dn_note_text_colour' data-colour-type='text'></div></div>";

		$backgroundColourLabel = $this->_('Background Colour');
		$backgroundColourMarkup = "<div class='uk-width-1-2@s'><h4>{$backgroundColourLabel}</h4><div id='dn_background_colour_picker' class='dn_colour_picker' data-colour='dn_note_background_colour' data-colour-type='background'></div></div>";

		$coloursMarkup = "<div uk-grid class='uk-grid'>{$textColourMarkup}{$backgroundColourMarkup}</div>";

		$f = $modules->get('InputfieldMarkup');
		$f->attr('value', $coloursMarkup);
		$f->label = $this->_('Default Colours');
		$f->notes = $this->_('Pick default text and background colours for all new notes. For texts, If none is picked, it will default to the current CSS text colour. For backgrounds, the default is no background colour. Please note this setting only applies when creating new notes.');

		$form->add($f);

		// hidden input to store selected default note text colour. a value of 0 means no colour set.
		$f = $modules->get('InputfieldHidden');
		$f->attr('id+name', 'dn_note_text_colour');
		// @note: we only save the values (e.g. "12,45,23,1")
		// @note: for display and for JS configs we add the correct formatting rgba() around the values
		$f->attr('value', $this->settings->textColour);

		$form->add($f);

		// hidden input to store selected default note background colour. a value of 0 means no colour set.
		$f = $modules->get('InputfieldHidden');
		$f->attr('id+name', 'dn_note_background_colour');
		$f->attr('value', $this->settings->backgroundColour);// @todo: need to change this->backgroundColour in scripts!

		$form->add($f);

		/* ## notes display sort ## */
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_sort');
		$f->attr('value', $this->settings->sort);
		$f->label =  $this->_('Display Sort');
		$f->notes = $this->_('How to sort display of notes. Please note that sorting by priority works only per 1 dashboard page view as opposed to across multiple results. Hence, it may not always work as expected.');

		$radioOptions = array (
			1 => $this->_('Date'),
			2 => $this->_('Title'),
			// @todo: unsure about this since requires setting priority as a note page propery during runtime
			3 => $this->_('Priority'),
		);

		$f->addOptions($radioOptions);

		$form->add($f);

		/* ## notes sort direction ## */
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_sort_direction');
		$f->attr('value', $this->settings->sortDir);
		$f->label =  $this->_('Sort Direction');

		$radioOptions = array (
			1 => $this->_('Ascending'),
			2 => $this->_('Descending'),
		);

		$f->addOptions($radioOptions);

		$form->add($f);

		/* ## notes edit each others' ## */
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_edit_others');
		$f->attr('value', $this->settings->editOther);
		$f->label =  $this->_('Users Can Edit Notes They Did Not Create?');
		$f->notes = $this->_("Specify if users can edit each other's notes. Users will still be able to respond to notes that allow responses.");

		$radioOptions = array (
			1 => $this->_('Yes'),
			2 => $this->_('No'),
		);

		$f->addOptions($radioOptions);

		$form->add($f);

		/* ## notes delete each others' ## */
		$f = $modules->get('InputfieldRadios');
		$f->attr('name', 'dn_note_delete_others');
		$f->attr('value', $this->settings->deleteOther);
		$f->label =  $this->_('Users Can Delete Notes They Did Not Create?');
		$f->notes = $this->_("Specify if users can delete each other's notes.");

		$radioOptions = array (
			1 => $this->_('Yes'),
			2 => $this->_('No'),
		);

		$f->addOptions($radioOptions);

		$form->add($f);

		/* ## notes maximum display per page ## */
		$f = $modules->get('InputfieldInteger');
		$f->attr('name', 'dn_note_max_display');
		$f->attr('value', $this->settings->displayMax);
		$f->label = $this->_('Display Limit');
		$f->description = $this->_('Maximum number of notes to display per page.');

		$form->add($f);

		/* ## note maximum reply depth ## */
		$f = $modules->get('InputfieldInteger');
		$f->attr('name', 'dn_note_max_reply_depth');
		$f->attr('value', $this->settings->maxReply);// 0 = no maximum
		$f->label = $this->_('Reply Depth');// @todo: change label?
		$f->description = $this->_('Maximum allowed nested depth for replies to notes. A value of 0 means no maximum.');

		$form->add($f);

		/* ## note maximum reply depth ## */
		$f = $modules->get('InputfieldInteger');
		$f->attr('name', 'dn_note_truncate_max');
		$f->attr('value', $this->settings->truncateMax);// 150
		$f->label = $this->_('Note Preview Maximum Characters');// @todo: change label?
		$f->description = $this->_('Maximum characters for truncation for note text preview in dashboard..');

		$form->add($f);

		/* ## notes dimensions in pixels ## */
		// width
		$f = $modules->get('InputfieldInteger');
		$f->attr('name', 'dn_note_width');
		$f->attr('value', $this->settings->width);
		$widthLabel = $this->_('Width');
		$widthMarkup = "<div class='uk-width-1-2@s'><h4>{$widthLabel}</h4><div id='dn_note_width' class='dn_note_dimensions'>{$f->render()}</div></div>";

		// height
		$f = $modules->get('InputfieldInteger');
		$f->attr('name', 'dn_note_height');
		$f->attr('value', $this->settings->height);
		$heightLabel = $this->_('Height');
		$heightMarkup = "<div class='uk-width-1-2@s'><h4>{$heightLabel}</h4><div id='dn_note_height' class='dn_note_dimensions'>{$f->render()}</div></div>";

		$dimensionsMarkup = "<div uk-grid class='uk-grid'>{$widthMarkup}{$heightMarkup}</div>";

		$f = $modules->get('InputfieldMarkup');
		$f->attr('value', $dimensionsMarkup);
		$f->label = $this->_('Note Dimensions');
		$f->notes = $this->_('Specify the dimensions you want notes to be displayed in in the dashboard. Please note these will applied as pixels. The value of truncating long preview texts above should be taken into consideration when specifying dimensions.');

		$form->add($f);

		########

		// save button
		$f = $modules->get('InputfieldSubmit');
		$f->attr('id+name', 'dn_notes_settings_btn');
		$f->showInHeader();
		$f->attr('value', $this->_('Save'));

		$form->add($f);

		// post: saving all note settings
		$post = $this->wire('input')->post;
		if($post->dn_notes_settings_btn) $this->save($form);

		$out .= $form->render();

		return $out;

	}


	/* ######################### - RENDER/MARKUP - ######################### */

	/**
	 * Render navigation for module pages use.
	 *
	 * @access private
	 * @return string $out Markup of rendered navigation.
	 *
	 */
	private function renderMenu() {

		$allNotesURL = $this->baseURL;
		$settingsURL = $this->baseURL . "/settings/";

		$allNotesText = $this->_('Notes');
		//$addNoteText = $this->_('Notes');
		$allNoteSettingsText = $this->_('Settings');

		$menuItemsArray = array(

			'all' => array( 'href' => $this->baseURL, 'link_text' => $allNotesText),
			'settings' =>  array( 'href' => $settingsURL, 'link_text' => $allNoteSettingsText),

		);

		$menuItems = '';
		$on = " class='dn_on uk-active'";
		$off = "";
		foreach ($menuItemsArray as $key => $value) {
			$href = $value['href'];
			$linkText = $value['link_text'];
			$class = '';
			if(!$this->urlSeg1 && $key != 'settings') $class = $on;
			elseif($this->urlSeg1 && $this->urlSeg1 == $key) $class = $on;

			$menuItems .= "<li><a href='{$href}'$class><span>{$linkText}</span></a></li>";
		}

		$out =
				"<nav class='uk-navbar-container uk-navbar-transparent' uk-navbar>" .
					"<div id='dn_menu' class='uk-navbar-left'>".
						"<ul class='nav uk-navbar-nav pw-primary-nav'>" .
							$menuItems .
						"</ul>" .
					"</div>" .
				"</nav>";

		return $out;

	}

	/**
	 * Render markup for link to create new note.
	 *
	 * @access private
	 * @return string $out Markup of link to create new note.
	 *
	 */
	private function renderCreateNote() {
		$createNoteText = $this->_('New Note');
		$createNoteURL = $this->baseURL . "/edit/";
		$out = "<a href='{$createNoteURL}' class='ui-helper-clearfix dn_create_note'><i class='fa fa-fw fa-plus-circle'></i>{$createNoteText}</a>";
		return $out;
	}

	/**
	 * Render notes for display on landing page.
	 *
	 * @access private
	 * @return string $out Markup of rendered notes for display.
	 *
	 */
	private function renderNotes($notes) {

		$out = '';
		$user = $this->wire('user');
		$urlParamPageNumStr = $this->wire('input')->pageNumStr() ? "?page=" . $this->wire('input')->pageNumStr() : "";
		$viewIcon = "<i class='fa fa-lg fa-eye'></i>";

		// asterisks @todo: use this?
		//$priorities = array(1=>"fa-arrow-circle-down",2=>"fa-minus-circle",3=>"fa-arrow-circle-up");
		// fa-exclamation-triangle  fa-exclamation-circle
		//$priorities = array(1=>"fa-arrow-circle-o-down",2=>"fa-minus-circle",3=>"fa-arrow-circle-o-up");
		$priorityClasses = array(1=>'dn_low_priority',2=>'dn_normal_priority',3=>'dn_high_priority');

		// @todo! edit!
		$out .= "<ul class='dn_notes_grid ui-helper-clearfix' data-gridmode='grid' data-gridsize='130'>";

		// loop through notes, building markup
		foreach ($notes as $note) {

			// add margin left if required
			#$classMarginLeft = $i ? " uk-margin-left" : "";
			// @todo: better presentation of truncated text?
			// @todo: what about long titles?! truncate?
			$viewURL = $this->baseURL . "/view/{$note->id}/{$urlParamPageNumStr}";
			$viewMarkup = "<a href='{$viewURL}' class='dn_note_view gridNote__edit'>" . $viewIcon. "</a>";

			## editing rights and markup
			// users not allowed to edit each other's notes and this user is not the note author
			$showEditMarkup = $this->checkEdit($note);

			if($showEditMarkup) {
				$viewEditDividerMarkup = "<span class='dn_note_view_edit_divider'>&#47;</span>";
				if($note->is(Page::statusLocked)){
					$editURL = '#';
					$editClass = 'gridNote__locked';
					$editIcon = "<i class='fa fa-lock'></i>";
					$editMarkup = "<a href='{$editURL}' class='{$editClass}'>" . $editIcon . "</a>";
				}
				// edit markup: note unlocked and can be edited (@note: including not global restriction on editing each other's notes)
				else {
					$editURL = $this->baseURL . "/edit/{$note->id}/{$urlParamPageNumStr}";
					$editClass = 'gridNote__edit';
					$editIcon = "<i class='fa fa-lg fa-pencil-square-o'></i>";
					$editMarkup = "<a href='{$editURL}' class='{$editClass}'>" . $editIcon . "</a>";
				}
			}
			else {
				$viewEditDividerMarkup = "";
				$editMarkup = "";
			}

			##################


			// @note: textColour NOT applied to div.dn_note
			$textColour = $note->textColour ? " style='color:rgba({$note->textColour});'" : '';
			// @todo: delete when done
			//$backgroundColour = $note->backgroundColour ? " style='background-color:rgba({$note->backgroundColour});'" : '';
			$backgroundColour = $note->backgroundColour ? "background-color:rgba({$note->backgroundColour});" : '';

			// note width + height + background colour inline CSS styles. applied to div.dn_note
			$width = "width:{$this->settings->width}px;";
			$height = "height:{$this->settings->height}px;";
			$noteWrapperStyles = " style='{$width}{$height}{$backgroundColour}'";

			// @todo: we'll use this to do visibility checks and skip if required
			$limitIDs = $note->limitVisibility > 1 && is_array($note->limitVisibilityIDs) ? implode("|",$note->limitVisibilityIDs) : '';

			// @todo: truncate first?

			// grab the comment text and clean it
			$text = htmlentities($note->text, ENT_QUOTES, "UTF-8");
			$text = str_replace("\n\n", "</p><p>", $text);
			$text = str_replace("\n", "<br />", $text);

			// @todo: revisit this! complete words do not show ...more!
			$text = $this->wire('sanitizer')->truncate($text, [
				'type' => 'punctuation',
				'maxLength' => $this->settings->truncateMax,
				'visible' => true,
				'keepFormatTags' => true,
				'more' => "...<small>(". $this->_('more').")</small>"// @todo?!
			  ]);

			// meta
			$date = date($this->dateFormat, $note->created);
			// @todo; configurable field to get author name!
			$author = $note->createdUser->name;
			// if note priority not set, it means note is "normal" so priority "2" set at runtime
			if(!$note->priority) $note->priority = 2;
			$notePriority = str_repeat("&#42;",$note->priority);
			//fa-comments, fa-comments-o, fa-comment, fa-comment-o
			$commentsCount = "<span class='fa fa-comments-o'><span class='dn_note_comments_count'>{$note->dashboard_note->count()}</span></span>";
			$priorityClass = " " . $priorityClasses[$note->priority];

			$metaDivider = "&#47;";
			$meta = "{$date} {$metaDivider} {$author} {$metaDivider} <span class='dn_note_priority_meta'>{$notePriority}</span>";

			##################

			// @todo: truncate $note->text + add Read More or View what if no comments?
			// @todo: edit as required! e.g., do we need li#id?! + the data-attr?
			$out .=
				"<li id='note-{$note->id}' class='gridNote ui-widget dn_note{$priorityClass}' data-note-value='{$note->id}'{$textColour}>" .
					"<div class='dn_note gridNote__overflow'{$noteWrapperStyles}>" .
						"<header class='uk-comment-header'>" .
							"<h4 class='uk-comment-title uk-margin-remove'{$textColour}>{$note->title}</h4>".
							"<div class='uk-comment-meta'{$textColour}>{$meta}</div>".
						"</header>" .
						// @todo: here and elsewhere, change these uk classes? are they not for comments?
						"<div class='uk-comment-body'>" . $text . "</div>" .
						"<div class='uk-position-bottom-right uk-text-small dn_note_footer'>" .
							"<span>{$commentsCount}</span>" .
						"</div>" .
					"</div>" .
					"<div class='gridNote__hover'>" .
						"<div class='gridNote__inner'>" .
							"<label class='gridNote__icon' for='' data-value='{$note->id}'>" .
								"<input class='dn_note_check gridNote__selectbox' id='note-{$note->id}' name='dn_selected_notes[]' type='checkbox' value='{$note->id}' data-media='{$note->id}'>" .
								"<span class='dn_select fa fa-check-square-o'></span>" .
							"</label>" .
							// @todo: add locked too! i.e. gridNote__locked + edit classes!
							"<span class='dn_note_view_edit'>" .
								//"<a href='{$viewURL}' class='dn_note_view gridNote__edit'>" . $viewIcon. "</a>" .
								$viewMarkup .
								$viewEditDividerMarkup .
								//"<a href='{$editURL}' class='{$editClass}'>" . $editIcon . "</a>" .
								$editMarkup .
							"</span>" .
						"</div>" .
					"</div>" .
				"</li>";
		}

		$out .= "</ul>";

		return $out;


	}


	/**
	 * Recursively render list of threaded replies/comments to notes.

	 * @param CommentArray $comments Array of comments.
	 * @param integer $depth How deep to nest..
	 * @param integer $parent At which point of the hierarchy to start rendering from.
	 * @param integer $first Helper parameter to know if on first list item.
	 * @return string $out Markup of threaded comments.
	 *
	 */
	private function renderThreadedReplies($comments, $depth = 1, $parent = 0, $first = 0) {

		$out = '';
		$depth -= 1;
		$replyText = $depth == 1 ? '' : $this->_('Reply');
		$hasChild = false;

		foreach ($comments as $comment) {

			// @todo: sort out \n and \t? not really important here though!

			// grab the comment text and clean it
			$commentText = htmlentities($comment->text, ENT_QUOTES, "UTF-8");
			$commentText = str_replace("\n\n", "</p><p>", $commentText);
			$commentText = str_replace("\n", "<br />", $commentText);

			$commentDate = date( $this->dateFormat, $comment->created);

			## - build nested comments - ##

			// if this comment item is a parent; create the inner-items/child-comment-items
			if ($comment->parent_id == $parent && $depth > 0) {
				// if this is the first child
				if ($hasChild === false) {
					$hasChild = true;// This is a parent
					if ($first == 0){
						$out .= "<ul id='dn_threaded_comments_main' class='dn_threaded_comments uk-comment-list'>";
						$first = 1;
					}
					else $out .= "<ul class='uk-comment-list dn_threaded_comments'>";
				}

				$out .=
					"<li>" .
						"<article class='uk-comment dn_response_wrapper'>" .
							"<header class='uk-comment-header'>" .
								"<h4 class='uk-comment-title'>{$comment->cite} - {$comment->id}</h4>" .
								"<div class='uk-comment-meta'>{$commentDate}</div>" .
							"</header>" .
							"<div class='uk-comment-body uk-text-small'>{$commentText}</div>" .

							// @todo: amend this! No need for some of the stuff here? Do we need the line?
							"<div class='dn_note_comment_footer uk-margin-small-top uk-text-small'>" .
								"<p class='dn_note_comment_action uk-margin-small'>" .
									"<a class='dn_note_comment_action_reply' data-comment-id='{$comment->id}' href='#'>" .
										$replyText .
									"</a>" .
								"</p>" .
							"</div>" .// close div.dn_note_comment_footer
						"</article>";
				######################### generate child-comment items [recursion] #########################
				$out .= $this->renderThreadedReplies($comments, $depth, $comment->id, $first);
				// close the <li>
				$out .= "</li>";
			}// end if parent

		}// end foreach $comments

		if ($hasChild === true) $out .= "</ul>";

		return $out;

	}

	/**
	 * Render markup of a note or comment's reply form.
	 *
	 * This is used for both when replying to the note itself or when replying to other comments (i.e. comment with a parent ID).
	 * When replying to other replies, this form is cloned on the fly using JavaScript.
	 *
	 * @access private
	 * @return void
	 */
	private function renderReplyMarkup() {

		$note = $this->note;
		$out = "";

		// if responses NOT allowed, return
		if(2 == $note->reply) return $out;

		$noteResponses = '';
		// if responses exist, fetch them
		if(!$note->dashboard_note->count()) {
			$noteResponses = "<p>" . $this->_('There are no responses to this note.') . "</p>";
		}
		else {
			$depth = $this->settings->maxReply ? $this->settings->maxReply + 1 : INF;
			$noteResponses = $this->renderThreadedReplies($this->note->dashboard_note,$depth);
		}

		// @TODO: NEED TO ADD BUTTONS TO CLONED FORMS!!!


		$modules = $this->wire('modules');

		// create form for all notes settings
		$form = $modules->get('InputfieldForm');
		$form->attr('id', 'dn_note_response_form');
		$form->action = './';
		$form->method = 'post';
		$form->description = $this->_('Responses');

		// inputfield markup to hold existing responses
		$f = $modules->get('InputfieldMarkup');
		$f->attr('value', $noteResponses);
		//$f->label =  $this->_('Responses ');
		//$f->label =  " ";
		//$f->skipLabelHeader = Inputfield::skipLabelHeader;

		$form->add($f);

		// new note: inputfield textarea
		$f = $modules->get('InputfieldTextarea');
		$f->attr('name', 'dn_note_response_text');
		$f->attr('value', "");
		$f->label = $this->_('Respond to this note');// @todo: change label?
		$f->rows = 5;

		$form->add($f);

		/*
			- inputfield markup to hold template reply form for cloning in JS
			- it contains a textarea and a hidden input for replying to exising comments/responses only
			- the textarea is for the text and the hidden input for the ID of the parent comment
			- the parent comment is the one being responded to (as opposed to a response to the note itself)
			- this form is hidden using CSS
		*/

		## hidden template for JS cloning ##


		// hidden textarea to clone in JS to use to store text of the response to an existing comment
		// its value will be changed in JS after cloning.
		// its name will also be changed to handle multiple inputs ([])
		$t = $modules->get('InputfieldTextarea');
		$t->attr('id+name', 'dn_response_text_template');
		$t->attr('value', "");
		$t->rows = 5;
		$responseToCommentTemplate = $t->render();

		// hidden input to clone in JS to use to store parent ID of the response to an existing comment
		// its value will be changed in JS after cloning. It cannot be 0!
		// its name will also be changed to handle multiple inputs ([])
		$t = $modules->get('InputfieldHidden');
		$t->attr('id+name', 'dn_response_parent_id_template');
		$t->attr('value', 0);
		$responseToCommentTemplate .= $t->render();

		$t = $modules->get('InputfieldSubmit');
		$t->attr('id', 'dn_response_reply_btn_template');
		$t->attr('name', 'dn_note_reply_btn');
		$t->attr('value', $this->_('Reply'));
		$responseToCommentTemplate .= $t->render();

		$responseToCommentTemplate = "<div id='dn_note_responses_template'>" . $responseToCommentTemplate ."</div>";

		$f = $modules->get('InputfieldMarkup');
		$f->attr('value', $responseToCommentTemplate);
		$f->class = "dn_hide";

		$form->add($f);

		## inputs relating to note ##

		// hidden input to store note page id
		$f = $modules->get('InputfieldHidden');
		$f->attr('id+name', 'dn_note_page_id');
		// @note: we only save the values (e.g. "12,45,23,1")
		// @note: for display and for JS configs we add the correct formatting rgba() around the values
		$f->attr('value', $this->note->id);
		$form->add($f);

		// hidden input to store parent id of the comment that is a response to the note itself. Its value will always be 0.
		$f = $modules->get('InputfieldHidden');
		$f->attr('id+name', 'dn_note_parent_id');
		$f->attr('value', 0);
		$form->add($f);

		// hidden input to store param string for pagination. Helps to properly redirect to viewing the note after submitting responses
		$f = $modules->get('InputfieldHidden');
		$f->attr('id+name', 'dn_note_pagination_num_str');
		$f->attr('value', $this->pageNumParamStr);
		$form->add($f);

		########

		// save button
		$f = $modules->get('InputfieldSubmit');
		$f->attr('id+name', 'dn_note_reply_btn');
		$f->attr('value', $this->_('Reply'));

		$form->add($f);

		// post: posting a response/comment to a note
		$post = $this->wire('input')->post;
		if($post->dn_note_reply_btn) $this->save($form);

		$out = "<div id='dn_note_responses'>" . $form->render() ."</div>";

		return $out;

	}

	/**
	 * Render hidden markup to store last selected note ID.
	 *
	 * Helps with the JS shift-selecting feature.
	 * Using shift, users can select all notes between a range.
	 *
	 * @access private
	 * @return string $out. Markup for shift-selection.
	 *
	 */
	private function renderShiftSelectMarkup() {
		$out = '<div id="mm_shift_select_wrapper" class="dn_hide"><input id="dn_previous_selected_note" type="hidden" value="0"></div>';
		return $out;
	}



	/* ######################### - CRUD ACTIONS - ######################### */

	/**
	 * Processes ProcessDashboardNotes form inputs (CRUD).
	 *
	 * CRUD - Processes all the form input sent from execute(), executeEdit() and executeView() (response forms).
	 *
	 * @access private
	 * @param object $form Sent form values.
	 *
	 */
	private function save($form) {

		$post = $this->wire('input')->post;

		// process form
		$form->processInput($post);

		// save new note or edit existing note
		if ($post->dn_note_edit_btn) $this->saveNote($post);
		// notes bulk actions: lock/unlock, trash/delete, change priority, allow replies
		elseif($post->dn_actions_btn) $this->saveBulkActions($post);
		// save: note replies
		elseif($post->dn_note_reply_btn) $this->saveNoteReply($post);
		// save: note settings
		elseif ($post->dn_notes_settings_btn) $this->saveSettings($post);

	}

	/**
	 * Save new or edit existing notes.
	 *
	 * @access private
	 * @param array $post Input Post with new or existing note to save.
	 *
	 */
	private function saveNote($post) {

		$pages = $this->wire('pages');
		$sanitizer = $this->wire('sanitizer');
		$session = $this->wire('session');
		$user = $this->wire('user');

		$notePageID = (int) $post->dn_note_page_id;
		$noteTitle = $sanitizer->text($post->dn_note_title);
		$noteName = $sanitizer->pageName($noteTitle);
		$noteText = $sanitizer->textarea($post->dn_note_text);
		$noteAfterSave = $sanitizer->fieldName($post->_action_value);
		$lockStatus = (int) $post->dn_note_locked;
		$nameClash = false;

		// hidden input that holds the pagination str in order to preserve for redirection and hence 'back to all links' to page where this note was at in the dashboard
		$paginationNumberStr = $sanitizer->pageName($post->dn_note_pagination_num_str);
		$urlParamPageNumStr = $paginationNumberStr ? "?page=" . $paginationNumberStr : "";

		// redirect back if no title or no text
		if (!$noteTitle || !$noteText)  {
			// @todo: error here, redirect!? ProcessWire will throw error anyway?
			$this->error($this->_('A title and text are required.'));
			$session->redirect($this->baseURL . "/edit/{$notePageID}/{$urlParamPageNumStr}");
		}

		$parent = $this->wire('page')->child('include=all');

		// settings
		$settingsArray = array();
		$settingsArray['text'] = $noteText;
		// only save note priority if either low (1) or high (3). Otherwise, we'll default to normal (1) at runtime
		$notePriority = (int) $post->dn_note_priority;
		if(2 != $notePriority) $settingsArray['priority'] = $notePriority;

		$settingsArray['textColour'] = str_replace(array("rgba(", ")"), "", $post->dn_note_text_colour);
		$settingsArray['backgroundColour'] = str_replace(array("rgba(", ")"), "", $post->dn_note_background_colour);

		// only save note reply setting if no replies allowed (2) Otherwise, we'll default to replies allowedl (1) at runtime
		$noteReply = (int) $post->dn_note_allow_replies;
		if(2 == $noteReply) $settingsArray['reply'] = $noteReply;

		// visibility access
		$noteLimit = (int) $post->dn_note_visibility_limit;
		$limitIDs = array();
		// only save limitVisibility if there is access control. Otherwise, we'll use default (1) (all can view all notes) at runtime
		if($noteLimit > 1) {
			$settingsArray['limitVisibility'] = $noteLimit;
			// limit by role
			if(2 == $noteLimit) $limitIDs = $sanitizer->intArray($post->dn_note_limit_role);
			// limit by permission
			elseif(3 == $noteLimit) $limitIDs = $sanitizer->intArray($post->dn_note_limit_permission);
			// limit by user
			elseif(4 == $noteLimit) $limitIDs = $sanitizer->intArray($post->dn_note_limit_users);
			$settingsArray['limitVisibilityIDs'] = $limitIDs;
		}

		// new note
		if(!$notePageID ) {
			$page = new Page();
			$page->template = "dashboard-note";
			$page->parent = $parent;
			// @todo: if new and locking, add lock!
			// sanitize and convert to a URL friendly page name
			if($parent->child("name={$noteName}, include=all")->id) $nameClash = true;
		}

		// existing note
		else {
			$page = $pages->get($notePageID);
			// no such page found
			// @todo: redirect back to edit page with error
			if(!$page) {
				$this->error($this->_('Note not found.'));
				// redirect with error
				$session->redirect($this->baseURL . "/edit/");
			}

			if($page->title != $noteTitle) {
				if($parent->child("name={$noteName}, include=all")->id) $nameClash = true;
			}
		}

		// name clash (note with specified name already exists), redirect
		if($nameClash) {
			$this->error($this->_('A note with that name already exists! Choose a different name.'));
			// redirect
			$session->redirect($this->baseURL . "/edit/{$page->id}/{$urlParamPageNumStr}");
		}

		// if NOT NEW NOTE and page locked ONLY save if removing lock
		if($notePageID && $page->is(Page::statusLocked)) {
			// if user is unlocking, then unlock, save and redirect
			if(2 == $lockStatus) {
				//  user is trying to unlock a locked note page. remove lock and redirect. no other saves!
				$page->removeStatus(Page::statusLocked);
				$page->save();
				$this->message($this->_('Note unlocked for edits.'));
				// redirect to edit after save
				$session->redirect($this->baseURL . "/edit/{$page->id}/{$urlParamPageNumStr}");
			}
			// else, error, page locked, user needs to unlock note page first
			else {
				$this->error($this->_('This note is locked for edits. Change its locked status first and save before continuing.'));
				// redirect to edit after save
				$session->redirect($this->baseURL . "/edit/{$page->id}/{$urlParamPageNumStr}");
			}
		}

		$page->title = $noteTitle;
		$page->name = $noteName;

		// if note page is getting locked as well
		if(1 == $lockStatus) $page->addStatus(Page::statusLocked);

		$settingsJSON = count($settingsArray) ? wireEncodeJSON($settingsArray) : '';// @note: wont save empties
		$page->dashboard_notes_settings = $settingsJSON;
		$page->save();

		// if note has limited visibility, we cache its ID and limitVisibilityIDs. this is for skipping this note from the selector to find notes to prevent users without access from viewing the note
		$savedCache = $this->getVisibilityLimitedNotesCache();
		if($noteLimit > 1 && count($limitIDs)) {
			$savedCache[$page->id] = $limitIDs;
			$this->setVisibilityLimitedNotesCache($savedCache);
		}
		// else we remove it from cache just in case  visibility access was changed to 'all can view'
		elseif(isset($savedCache[$page->id])) {
			unset($savedCache[$page->id]);
			$this->setVisibilityLimitedNotesCache($savedCache);
		}

		$this->message($this->_('Note saved.'));
		// if limiting access and no access criteria values selected (i.e. no roles, permissions or users set), warn the user
		if($noteLimit > 1 && !count($limitIDs)) {
			$limitVisibilityByText = array(
				2 => $this->_('Roles'),
				3=> $this->_('Permissions'),
				4 => $this->_('Users'),
			);
			$limitText = $limitVisibilityByText[$noteLimit];
			$warning = sprintf(__('You need to specify the %1$s you wish to limit the visibility of this note by (%2$s).'), $limitText, "<em>$page->title</em>");
			$this->warning($warning, Notice::allowMarkup);
		}

		/*
			# determine redirection # @note: we preserve url param strings if possible!
			- Five possibilities here:
			1. Save and continue editing (default)
			2. Save + Exit
			3. Save + Add New note
			4. Save + View note
			5. Save + Edit next sibling note
		*/

		// save + exit: back to dashboard (keep pagination info!)
		if('exit' == $noteAfterSave)  $session->redirect($this->baseURL . "/{$paginationNumberStr}");
		// save + new: got to add new note screen. no need for any url param string
		elseif('new' == $noteAfterSave) $session->redirect($this->baseURL . "/edit/");
		// save + view: view this note but build correct url param string
		elseif('view' == $noteAfterSave) $session->redirect($this->baseURL . "/view/{$page->id}/{$urlParamPageNumStr}");
		// next: go edit next accessible note but build correct url param string for IT
		// accessibility checks for two things: (i) can the user view the note? (ii) do the global settings allow editing each other's notes?
		// @note: these restrictions do not apply to superusers
		elseif('next' == $noteAfterSave) {
			// selector for finding notes
			$selector = "include=all,parent!=7";
			if(!$user->isSuperuser()) {
				// check for visibility restrictions
				$excludedIDs = $this->getVisibilityLimitedNotesIDs();
				if(strlen($excludedIDs)) $selector .= ",id!={$excludedIDs}";
				// check for global editing restrictions (edit each other's notes)
				if(2 == $this->settings->editOther) $selector .= ",created_users_id={$user->id}";
			}
			$next = $page->next($selector);
			// @note: there is not guarantee that the next page will be on the same pagination as the current page! we can't help that
			if($next->id) $pageID = $next->id;
			// no next page, so stay where we are
			else {
				$pageID = $page->id;
				// warning that no next note to edit found
				$this->warning($this->_('No next note to edit.'));
			}
			$session->redirect($this->baseURL . "/edit/{$pageID}/{$urlParamPageNumStr}");
		}
		// stay on this page to continue editing it
		else $session->redirect($this->baseURL . "/edit/{$page->id}/{$urlParamPageNumStr}");

	}

	/**
	 * Bulk actions for selected notes.
	 *
	 * Actions are: lock, unlock, change priority (low/normal/high), trash and delete
	 * @access private
	 * @param array $post Input Post with notes to bulk action.
	 *
	 */
	private function saveBulkActions($post) {

		$sanitizer = $this->wire('sanitizer');
		$action = $sanitizer->fieldName($post->dn_action_select);
		$notesIDs = $sanitizer->intArray($post->dn_selected_notes);
		// hidden input that holds the pagination str in order to preserve for redirection after bulk action
		$pageNumStr = $sanitizer->pageName($post->dn_note_pagination_num);

		## catch submission errors

		// no notes selected for actioning @note: not really possible since "apply" button only shows in notes selected. But just in case
		if(!count($notesIDs))  {
			$this->error($this->_('No notes selected for actioning!'));
			return;
		}
		// no action selected
		if(!$action)  {
			$this->error($this->_('No action selected!'));
			return;
		}

		$pages = $this->wire('pages');
		$i = 0;
		$j = 0;
		$priorities = array('priority_low' => 1, 'priority_normal' => 2, 'priority_high' => 3);

		foreach($notesIDs as $noteID) {

			## pre-processing checks ##
			$page = $pages->get($noteID);
			if(!$page) {
				$j++;
				continue;
			}

			// if note locked for edits and action is not unlocking, skip it
			if($page->is(Page::statusLocked) && $action !='unlock') {
				$j++;
				continue;
			}

			## apply actions ##

			// lock/unlock
			if(in_array($action, array('lock','unlock'))) {
				// unlock note
				if('unlock' == $action) {
					$page->removeStatus(Page::statusLocked);
					$page->save();
					// confirm successfully unlocked
					if (!$page->is(Page::statusLocked)) $i++;
					else $j++;
				}
				// lock note
				else {
					$page->addStatus(Page::statusLocked);
					$page->save();
					// confirm successfully locked
					if ($page->is(Page::statusLocked)) $i++;
					else $j++;
				}
			}
			// change priority
			elseif(in_array($action, array('priority_low','priority_normal','priority_high'))) {
				$priority = $priorities[$action];
				$noteSettings = json_decode($page->dashboard_notes_settings, true);
				// if priority is normal, no need to save it but unset old value,
				if(2 == $priority && isset($noteSettings['priority'])) unset($noteSettings['priority']);
				// else set if low or high
				else $noteSettings['priority'] = $priority;
				$page->dashboard_notes_settings = wireEncodeJSON($noteSettings);
				$page->save('dashboard_notes_settings');
				$i++;
			}

			// trash/delete
			elseif(in_array($action,array('trash','delete'))) {

				// if users cannot delete each others notes, skip if current user is not the note author
				if(($this->settings->deleteOther == 2 && $page->createdUser != $this->wire('user')) || ($page->is(Page::statusLocked))){
					$j++;
					continue;
				}
				// delete
				if('delete' == $action) {
					$page->delete();// delete the page
					$deletedPage = $pages->find("id=" . $noteID);
					if(!$deletedPage->id) $i++;// confirm deleted
					else $j++;// found page but for some reason failed to delete

				}
				// trash
				else {
					$pages->trash($page);// trash the page
					if($page->is(Page::statusTrash)) $i++;// confirm trashed;
					else $j++;// found page but for some reason failed to trash
				}

			}




		}

		## messages ##
		// success messages
		$actionTakenArray = array(
			'success' => array(
				'lock' => sprintf(_n("Locked %d note .", "Locked %d notes.", $i), $i),
				'unlock' => sprintf(_n("Unlocked %d note .", "Unlocked %d notes.", $i), $i),
				'priority_low' => sprintf(_n("Low priority applied to %d note .", "Low priority applied to %d notes.", $i), $i),
				'priority_normal' => sprintf(_n("Normal priority applied to %d note .", "Normal priority applied to %d notes.", $i), $i),
				'priority_high' => sprintf(_n("High priority applied to %d note .", "High priority applied to %d notes.", $i), $i),
				'trash' => sprintf(_n("Trashed %d note.", "Trashed %d notes.", $i), $i),
				'delete' => sprintf(_n("Deleted %d note.", "Deleted %d notes.", $i), $i),
			),
			'fail' => array(
				'lock' => $this->_("Unable to lock selected notes."),
				'unlock' => $this->_("Unable to unlock selected notes."),
				'priority' => $this->_("Unable to change priority of selected notes."),
				'trash' => $this->_("Unable to trash selected notes"),
				'delete' => $this->_("Unable to delete selected notes"),
			)
		);

		// success
		if($i > 0) {
			$this->message($actionTakenArray['success'][$action]);

		}
		// error
		else {
			$failActionString = in_array($action,array('priority_low','priority_normal','priority_high')) ? $actionTakenArray['fail']['priority'] : $actionTakenArray['fail'][$action];
			$this->error($failActionString);
		}

		// warnings (locked or cannot delete each other's notes)
		if($j) {
			$warningActionString = sprintf(_n("%d note locked for edits or cannot be trashed. No action applied to it.", "%d notes locked for edits or cannot be trashed. No action applied to them.", $j), $j);
			$this->warning($warningActionString);
		}

		$pageNumStr = $pageNumStr ? "/{$pageNumStr}" : "";
		$this->wire('session')->redirect($this->baseURL . "{$pageNumStr}");


	}

	/**
	 * Save one or more responses to a note or a note's existing responses.
	 *
	 * This can come from the main form on the page or forms built on the fly for nested responses.
	 *
	 * @access private
	 * @param array $post Input Post with new responses to save.
	 *
	 */
	private function saveNoteReply($post) {

		$notePageID = (int) $post->dn_note_page_id;

		// check if we have a page to save to
		$page = $this->wire('pages')->get($notePageID);
		if(!$page) {
			$this->error($this->_('We could not find that page!'));
			$this->wire('session')->redirect($this->baseURL);
		}

		$user = $this->wire('user');
		$sanitizer = $this->wire('sanitizer');

		// hidden input that holds the pagination str in order to preserve for redirection and hence 'back to all links' to page where this note was at in the dashboard
		$paginationNumberStr = $sanitizer->pageName($post->dn_note_pagination_num_str);
		$urlParamPageNumStr = $paginationNumberStr ? "?page=" . $paginationNumberStr : "";

		// direct response to note itself
		$noteResponseParentID = 0;// this will always be zero anyway
		$noteResponseText = $sanitizer->textarea($post->dn_note_response_text);

		// responses to existing comments/responses @note: arrays
		$responsesToResponsesParentIDs = $post->dn_response_parent_id;
		$responsesToResponsesText = $post->dn_response_text;

		##  process and save comments/responses ##
		$page->of(false);$i = 0;
		// responses to responses
		if(is_array($responsesToResponsesParentIDs) && count($responsesToResponsesParentIDs)) {
			foreach($responsesToResponsesParentIDs as $key => $parentID) {
				$text = $sanitizer->textarea($responsesToResponsesText[$key]);
				// skip if no response text
				if(!strlen($text)) continue;
				// create and add new comment
				$c = new Comment();
				$c->text = $text;
				$c->cite = $user->get('title|name');
				$c->email = $user->email;// @todo: do we really need this?
				$c->parent_id = (int) $parentID;
				$c->created_users_id = $user->id;
				$page->dashboard_note->add($c);
				$i++;
			}
		}

		// add main/direct response to note
		if(strlen($noteResponseText)) {
			$c = new Comment();
			$c->text = $noteResponseText;
			$c->cite = $user->get('title|name');
			$c->email = $user->email;// @todo: do we really need this?
			$c->created_users_id = $user->id;
			$page->dashboard_note->add($c);
			$i++;
		}

		## save + messages ##
		if($i) {
			// save only if something posted!
			$page->save('dashboard_note');
			$page->of(true);
			$message = sprintf(_n("Save %d response.", "Saved %d responses.", $i), $i);
			$this->message($message);
		}
		else $this->error($this->_('No responses received!'));

		$this->wire('session')->redirect($this->baseURL . "/view/{$page->id}/{$urlParamPageNumStr}");

	}

	/**
	 * Save global default notes settings.
	 *
	 * @access private
	 * @param array $post Input Post with notes settings.
	 * @access private
	 *
	 */
	private function saveSettings($post) {

		$pages = $this->wire('pages');
		$sanitizer = $this->wire('sanitizer');

		$notesSettingsPage = $this->wire('page')->child('include=all,template=dashboard-notes');

		// settings
		$settingsArray = array();
		$settingsArray['dateFormat'] = (int) $post->dn_note_date_format;
		$settingsArray['dateMonthLabel'] = (int) $post->dn_note_date_month_label;
		$settingsArray['textColour'] = $sanitizer->text(str_replace(array("rgba(", ")"), "", $post->dn_note_text_colour));
		$settingsArray['backgroundColour'] = $sanitizer->text(str_replace(array("rgba(", ")"), "", $post->dn_note_background_colour));
		$settingsArray['sort'] = (int) $post->dn_note_sort;
		$settingsArray['sortDir'] = (int) $post->dn_note_sort_direction;
		$settingsArray['editOther'] = (int) $post->dn_note_edit_others;
		$settingsArray['deleteOther'] = (int) $post->dn_note_delete_others;
		$settingsArray['displayMax'] = (int) $post->dn_note_max_display;
		$settingsArray['maxReply'] = (int) $post->dn_note_max_reply_depth;
		// max characters for truncation for note text preview in dashboard
		$settingsArray['truncateMax'] = (int) $post->dn_note_truncate_max;
		// note dispaly width and height: for dashboard display using inline CSS in pixels
		$settingsArray['width'] = (int) $post->dn_note_width;
		$settingsArray['height'] = (int) $post->dn_note_height;

		// save
		$settingsJSON = count($settingsArray) ? wireEncodeJSON($settingsArray) : '';// @note: wont save empties
		$notesSettingsPage->dashboard_notes_settings = $settingsJSON;
		$notesSettingsPage->save('dashboard_notes_settings');

		$this->message($this->_('Settings saved.'));
		// @note: needed to properly reload page, i.e. to trigger loading of JS config scripts, hence redirect here
		$this->wire('session')->redirect($this->baseURL . "/settings/");

	}

	/* ######################### - GETTERS - ######################### */

	/**
	 * Get limited number of notes to display in dashboard.
	 *
	 * @access private
	 * @return PageArray $notes Limited number of notes pages.
	 *
	 */
	private function getNotes() {

		$limit = (int) $this->settings->displayMax;

		$sorting = array(1=>"created",2=>"title",3=>"priority");
		$sort = $sorting[(int)$this->settings->sort];
		if(2 == $this->settings->sortDir) $sort = "-{$sort}";

		// selector for finding notes
		$selector = "template=dashboard-note,include=all,parent!=7,limit={$limit},sort=$sort";
		/*
			- for non-superusers only...
			- check if we have visibility limited notes that current user cannot view
			- if true we exclude them using IDs
		*/
		if(!$this->wire('user')->isSuperuser()) {
			$excludedIDs = $this->getVisibilityLimitedNotesIDs();
			if(strlen($excludedIDs)) $selector .= ",id!={$excludedIDs}";
		}

		$notes = $this->wire('pages')->find($selector);

		if($notes->count()) {
			// set extra note properties (priority, etc)
			$notes->each(function($note) use($notes){
				$noteSettingsJSON = $note->dashboard_notes_settings;
				$data = json_decode($noteSettingsJSON, true);
				if(is_array($data) && count($data))$note->setArray($data);
			});

			// sort notes by priority if required (in-memory)
			if($this->settings->sort == 3) $notes->sort("{$sort}");
		}

		return $notes;

	}

	/**
	 * Fetch cached data for notes whose visibility is limited.
	 *
	 * Only notes whose visibity is limited (value>2) are cached.
	 * We use this to exclude from the dashboard notes that the current user is not allowed to see.
	 * We use the IDs of the notes in the selector to get notes. @see getNotes()
	 *
	 * @access private
	 * @return array $cacheData Array of notes pages IDs that will be excluded from find notes selector.
	 *
	 */
	private function getVisibilityLimitedNotesCache() {
		$cacheName = 'dashboard-notes';
		$cacheData = $this->wire('cache')->get($cacheName);
		$cacheData = is_array($cacheData) ? $cacheData : array();
		return $cacheData;
	}

	/**
	 * Get IDs of note pages that the current user has no visibility access to.
	 *
	 * We use this to exclude from the dashboard notes that the current user is not allowed to see.
	 * We use the IDs of the notes in the selector to get notes. @see getNotes()
	 *
	 * @access private
	 * @return string $excludedIDsStr If exclusions found, pipe-separated string of page IDs of notes user cannot view, else empty.
	 *
	 */
	private function getVisibilityLimitedNotesIDs() {

		$excludedIDsStr = "";
		$excludedIDsCache = $this->getVisibilityLimitedNotesCache();

		// get array of current user's ID, roles IDs and permission IDs
		$userIDs = $this->getUserIDs();
		if(is_array($excludedIDsCache) && count($excludedIDsCache)) {
			$excludedIDs = array();
			foreach ($excludedIDsCache as $pageID => $limitIDs) {
				// user has access, so skip @note: this works because users, roles and permissions are all pages, hence have unique page IDs
				if(count(array_intersect($userIDs, $limitIDs))) continue;
				// array of pageIDs of notes user cannot view
				$excludedIDs[] = $pageID;
			}
			if(count($excludedIDs)) $excludedIDsStr = implode("|",$excludedIDs);
		}

		return $excludedIDsStr;

	}

	/**
	 * Get IDs of current users ID, roles and permissions.
	 *
	 * Uses in conjunction with getVisibilityLimitedNotesIDs() to determine IDs of pages of notes that the user does not have access to.
	 *
	 * @access private
	 * @return array $userIDs Array of IDs of current users IDs, roles and permissions.
	 *
	 */
	private function getUserIDs() {

		$user = $this->wire('user');
		$userIDs = array();

		// for user limited notes
		$userIDs[] = $user->id;
		// for role limited notes
		foreach($user->roles as $role) {
			if($role->name == 'guest') continue;
			$userRoles[] = $role->id;
		}
		// for permission limited notes
		$userPermissions = $user->getPermissions()->explode('id');
		$userIDs = array_merge($userIDs, $userRoles, $userPermissions);

		return $userIDs;

	}

	/**
	 * Get all user's roles (minus guest) for selection for note visibility.
	 *
	 * @note: we limit these to only the current user's permissions.
	 * It doesn't make sense to access-control if user will not have access to that role.
	 * E.g. if they limit by a permission they do not have Or..
	 *
	 * @access private
	 * @return void
	 *
	 */
	private function getRoles() {
		$roles = array();
		foreach($this->wire('user')->roles as $role) {
			if($role->name == 'guest') continue;
			$roles[$role->id] = $role->name;
		}
		return $roles;
	}

	/**
	 * Get all user's permissions for selection for note visibility.
	 *
	 * @note: we limit these to only the current user's permissions.
	 * It doesn't make sense to access-control if user will not have access to that role.
	 * E.g. if they limit by a permission they do not have Or..
	 *
	 * @access private
	 * @return void
	 *
	 */
	private function getPermissions() {
		$permissions = array();
		foreach($this->wire('user')->getPermissions() as $permission) {
			$permissions[$permission->id] = $permission->get("title|name");
		}
		return $permissions;
	}

	/**
	 * Get all users (minus guest user) for selection for note visibility.
	 *
	 * @access private
	 * @return void
	 *
	 */
	private function getUsers() {
		// @todo: should non-superusers be able to see superusers names in this list? I don't think so?! or?
		$users = array();
		foreach($this->wire('users') as $user) {
			if($user->name == 'guest') continue;
			$users[$user->id] = $user->name;
		}
		return $users;
	}

	/* ######################### - SETTERS - ######################### */

	/**
	 * Set class properties for adding versus editing a note.
	 *
	 * @access private
	 * @return void
	 *
	 */
	private function setNoteValues() {

		$defaultSettings = array('priority'=>2,'textColour'=>0,'backgroundColour'=>0,'reply'=>1,'locked'=>2,'limitVisibility'=>1,'limitVisibilityIDs'=>array());
		$savedSettings = array();

		$notePageID =  $this->wire('sanitizer')->pageName($this->wire('input')->urlSegment2);
		if($notePageID) {
			$page = $this->wire('pages')->get($notePageID);
			if($page->id > 0) {
				$this->note = $page;
				// ## settings ##
				$savedSettings = json_decode($page->dashboard_notes_settings, true);
				if($page->is(Page::statusLocked)) $savedSettings['locked'] = 1;
			}
			// no page found, go back to all notes
			else $this->wire('session')->redirect($this->baseURL);
		}
		// new note: instantiate empty WireData()
		else {
			$this->note = new WireData();
			// check if we have default colours for NEW notes set
			if($this->settings->textColour) $defaultSettings['textColour'] = $this->settings->textColour;
			if($this->settings->backgroundColour) $defaultSettings['backgroundColour'] = $this->settings->backgroundColour;
		}

		$settings = array_merge($defaultSettings,$savedSettings);

		// set property values to WireData $this->settings;
		$this->note->setArray($settings);
		// @note: these note colour properties are  also used for JS config scripts sent to browser
		$this->noteTextColour = $this->note->textColour;
		$this->noteBackgroundColour = $this->note->backgroundColour;

	}

	/**
	 * Set class properties for global settings.
	 *
	 * @access private
	 * @return void
	 *
	 */
	private function setGlobalNoteValues() {

		$defaultSettings = array('dateFormat'=>1,'dateMonthLabel'=>2,'textColour'=>0,'backgroundColour'=>0,'sort'=>1,'sortDir'=>2,'editOther'=>1,'deleteOther'=>1,'displayMax'=>12,'maxReply'=>0, 'truncateMax'=>150,'width'=>300,'height'=>260);

		$notesSettingsPage = $this->wire('page')->child('include=all');
		$savedSettingsJSON = $notesSettingsPage->dashboard_notes_settings;
		$savedSettings = $savedSettingsJSON ? json_decode($savedSettingsJSON, true) : array();
		$settings = array_merge($defaultSettings,$savedSettings);
		// set property values to WireData $this->settings;
		$this->settings->setArray($settings);
		// @note: these note colour properties are  also used for JS config scripts sent to browser
		$this->noteTextColour = $this->settings->textColour;
		$this->noteBackgroundColour = $this->settings->backgroundColour;

	}

	/**
	 * Create cache of notes whose visibility is limited.
	 *
	 * This is for use with saveNote().
	 *
	 * @access private
	 * @param array $items Array of $note->id => $note->limitVisibilityIDs pairs to cache.
	 *
	 */
	private function setVisibilityLimitedNotesCache($items) {
		$cacheName = 'dashboard-notes';
		$this->wire('cache')->save($cacheName, $items, WireCache::expireNever);
	}

	/* ######################### - UTILITIES - ######################### */

	/**
	 * Check if a user has access to view/edit the specified note page based on note's visibility criteria.
	 *
	 * Access can be limited by role, permissions or users.
	 * If in dashboard, skip to display such pages.
	 * If URL to view/edit accessed directly, we will redirect to dashboard (note here!).
	 *
	 * @access private
	 * @param Page $note The Note whose access is to be determined.
	 * @return bool $access True if user has access else false
	 *
	 */
	private function checkAccess($note) {

		$access = false;

		$user = $this->wire('user');
		$limitIDs = $note->limitVisibilityIDs;
		$visibility = $note->limitVisibility;

		// if no limitVisibilityIDs set, just return true @note: on save, users are warned about this!
		if(!is_array($limitIDs) || !count($limitIDs)) return true;

		// check access: roles
		if(2 == $visibility) {
			// iterate saved IDs to limit by and check for first hit in user roles then break
			foreach($limitIDs as $id) {
				if($user->hasRole($id)) {
					$access = true;
					break;
				}
			}
		}
		// check access: permission
		elseif(3 == $visibility) {
			// iterate saved IDs to limit by and check for first hit in user permissions then break
			foreach($limitIDs as $id) {
				if($user->hasPermission($id)) {
					$access = true;
					break;
				}
			}
		}
		// check access: users (but NOT SUPERUSERS!)
		elseif(4 == $visibility) {
			// if current logged in user's ID is one of the allowed user ids OR is a superuser, access is true
			if(in_array($user->id,$limitIDs) || $user->isSuperuser()) $access = true;
		}

		return $access;

	}

	/**
	 * Determines if a user can edit a given note based on certain global restrictions.
	 *
	 * If user is superuser, user can edit.
	 * If global settings do not allow authors to edit each other's notes but current user is note author, user can edit.
	 * If there are no global restrictions, user can edit.
	 * No editing allowed in all other cases.
	 *
	 * @access private
	 * @param Page $note The Note whose editing access is to be determined.
	 * @return bool $canEdit True if user can edit Note page, else false.
	 *
	 */
	private function checkEdit($note) {
		$user = $this->wire('user');
		$canEdit = false;
		if(1 == $this->settings->editOther || $note->createdUser == $user || $user->isSuperuser() || !$note->id) $canEdit = true;
		return $canEdit;
	}

	/* ######################### - INSTALLERS - ######################### */


	/**
	 * Called only when the module is installed.
	 *
	 * A new page with this Process module assigned is created.
	 * A new permission 'dashboard-notes' is created.
	 * 3 fields are created.
	 * A new template 'menu_pages' is created.
	 *
	 * @access public
	 *
	 */
	public function ___install() {

		// create ProcessDashboardNotes admin page and permission if verifyInstall() was successful in its validation
		if($this->verifyInstall($mode = null) == true) {
			$page = new Page();
			$page->template = 'admin';
			$page->parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
			$page->title = 'Dashboard Notes';
			$page->name = self::PAGE_NAME;
			$page->process = $this;
			#$page->addStatus(Page::statusHidden);
			$page->save();

			$this->verifyInstall($mode = 1);// run Dashboard Notes Installer

			// tell the user we created this page
			$this->message("Dashboard Notes: Created page {$page->path}");
		}

		else throw new WireException($this->_('Dashboard Notes: Installation aborted. Check and fix reported errors first.'));

		// create the permission 'dashboard-notes' and 'dashboard-notes-settings' to limit access to the module
		$perms = array(
			'dashboard-notes' => $this->_('Use Dashboard Notes'),
			'dashboard-notes-settings' => $this->_('View and Edit Dashboard Notes Settings'),
		);

		foreach ($perms as $k => $v) {
			$permission = $this->wire('permissions')->get($k);
			if (!$permission->id) {
				$p = new Permission();
				$p->name = $k;
				$p->title = $v;
				$p->save();
			}
		}

		// tell the user we created this module's permissions
		$this->message('Dashboard Notes: Created new permissions dashboard-notes and dashboard-notes-settings.');

	}

	/**
	 * Called only when the module is uninstalled.
	 *
	 * This should return the site to the same state it was in before the module was installed.
	 * Deletes 3 fields, template and permission created on install as well as created menu pages.
	 *
	 * @access public
	 *
	 */
	public function ___uninstall() {

		$pages = $this->wire('pages');

		// find and delete the page we installed, locating it by the process field (which has the module ID)
		// it would probably be sufficient just to locate by name, but this is just to be extra sure.
		$moduleID = $this->wire('modules')->getModuleID($this);
		$dnPage = $pages->get("template=admin, process=$moduleID, name=" . self::PAGE_NAME);
		// $page = $pages->get('template=admin, name='.self::PAGE_NAME);

		if($dnPage->id) {
			// if we found the page, let the user know and delete it
			$this->message($this->_('Dashboard Notes: Deleted Page: ') . $dnPage->path);
			// recursively delete the dashboard notes page (i.e. including all its children (the note parent and its children the notes pages))
			$pages->delete($dnPage, true);
			// also delete any note pages that may have been left in the trash
			foreach ($pages->find('template=dashboard-note, status>=' . Page::statusTrash) as $p) $p->delete();
		}

		// find and delete the Dashboard Notes permissions and let the user know
		$perms = array('dashboard-notes','dashboard-notes-settings');

		foreach ($perms as $p) {
			$permission = $this->wire('permissions')->get($p);
			if ($permission->id) $permission->delete();
		}

		// tell the user we created this module's permission
		$this->message('Dashboard Notes: Deleted permissions dashboard-notes and dashboard-notes-settings.');

		#############

		// find and delete the 2 templates used by our notes
		$templates = array('dashboard-note', 'dashboard-notes');
		foreach ($templates as $template) {
			$t = $this->wire('templates')->get($template);
			if($t->id) {
				$this->wire('templates')->delete($t);
				$this->wire('fieldgroups')->delete($t->fieldgroup);// delete the associated fieldgroups
			}
		}
		$this->message('Dashboard Notes: Deleted Templates dashboard-note and dashboard-notes');

		#############

		// find and delete the 2 fields used by our notes
		$fields = array('dashboard_note', 'dashboard_notes_settings');
		foreach ($fields as $field) {
			$f = $this->wire('fields')->get($field);
			if($f->id) $this->wire('fields')->delete($f);
		}
		$this->message('Dashboard Notes: Deleted Fields dashboard_note and dashboard_notes_settings');

		// delete the visibility limit cache
		$this->wire('cache')->delete("dashboard-notes");// delete the cache

	}

	/**
	 * Check if similar fields, templates and dashboard notes page exist before install.
	 *
	 * @access public
	 * @param null|integer $mode Whether to verify install possible (null) or commence install (1).
	 *
	 */
	public function verifyInstall($mode = null) {

		$pageCheck = '';

		// if we have already verified install, proceed directly to first step of installer
		if($mode == 1) return $this->createFields();

		// 1. ###### First we check if Dashboard Notes Admin page, fields and templates already exist.
		// If yes to any of these, we abort installation and return error messages

		// check if Dashboard Notes page already exists in Admin
		$parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$page = $this->wire('pages')->get("parent=$parent, template=admin, include=all, name=".self::PAGE_NAME);
		if($page->id && $page->id > 0) $pageCheck = $page->title;

		$pageExist = $pageCheck ? true : false;// we'll use this later + $pageCheck to show error

		// check if Dashboard Notes fields already exist
		$fields  = array('note' => 'dashboard_note','settings' => 'dashboard_notes_settings');

		$fieldsCheck = array();
		foreach ($fields as $key => $value) {if($this->wire('fields')->get($value)) $fieldsCheck [] = $this->wire('fields')->get($value)->name;}
		$fieldsExist = count($fieldsCheck) ? true : false;

		$templates = array('note' => 'dashboard-note','notes' => 'dashboard-notes');

		$templatesCheck = array();
		foreach ($templates as $template) {if($this->wire('templates')->get($template)) $templatesCheck [] = $this->wire('templates')->get($template)->name;}

		$templatesExist = count($templatesCheck) ? true : false;

		if($pageExist == true){
			$failedPage = $pageCheck;
			$this->error($this->_("Cannot install Dashboard Notes Admin page. A page named 'dashboard-notes' is already in use under Admin. Its title is: {$failedPage}."));
		}

		if($fieldsExist == true){
			$failedFields = implode(', ', $fieldsCheck);
			$this->error($this->_("Cannot install Dashboard Notes fields. Some field names already in use. These are: {$failedFields}."));
		}

		if($templatesExist == true){
			$failedTemplates = implode(', ', $templatesCheck);
			$this->error($this->_("Cannot install Dashboard Notes templates. Some template names already in use. These are: {$failedTemplates}."));
		}

		//if any of our checks returned true, we abort early
		if($pageExist == true || $fieldsExist == true || $templatesExist == true) {
			throw new WireException($this->_('Due to the above errors, Dashboard Notes did not install. Make necessary changes and try again.'));
			//due to above errors, we stop executing install of the following 'templates', 'fields' and 'pages'
		}

		// pass on to first step of install
		// return true to OK first step of install
		return true;

	}

	/**
	 * Create several Dashboard Notes fields.
	 *
	 * @note: We create from JSON using Field::setImportData().
	 *
	 * @access private
	 * @return $this->createTemplates().
	 *
	 */
	private function createFields() {

		// 2. ###### We create the fields we will need to add to our templates ######

		$fields = $this->getFieldData();
		$fieldNames = '';

		foreach ($fields as $fieldName => $fieldData) {
			$f = new Field();
			$f->setImportData($fieldData);
			$f->save();
			$fieldNames .= $fieldName . " ";
		}

		$this->message("Dashboard Notes: Created fields $fieldNames");

		// lets create some templates and add our fields to them
		return $this->createTemplates();

	}

	/**
	 * Create several Dashboard Notes templates.
	 *
	 * Create templates one each for the Dashboard Notes Notes parent and for individual Notes pages.
	 * @note: We create from JSON using Template::setImportData().
	 *
	 * @access private
	 * @return $this->extraTemplateSettings().
	 *
	 */
	private function createTemplates() {

		// 3. ###### We create the templates needed by Dashboard Notes ######

		$templates = $this->getTemplateData();
		$templateNames = '';

		foreach ($templates as $templateName => $templateData) {
			$fg = new Fieldgroup();
			$fg->name = $templateName;
			$templateNames .= $templateName . " ";
			foreach ($templateData['fieldgroupFields'] as $fieldname) $fg->add($fieldname);
			$fg->save();
			$t = new Template();
			$t->setImportData($templateData) ;
			$t->save();
		}

		$this->message("Dashboard Notes: Created templates $templateNames");

		/* @todo?
		// need to create this blank template file 'dashboard-notes.php' to enable MM to appear in the admin menu (view-access issues)
		$path = $this->wire('config')->paths->templates . 'dashboard-notes.php';
		if(!is_file($path)) {
			$notice = "<?php namespace ProcessWire;\n\n#### - Intentionally left blank. Please do not delete this file - ###";
			$notesTemplateFile = fopen($path, 'a');
			fwrite($notesTemplateFile, $notice);
			fclose($notesTemplateFile);
		}*/

		// add some extra settings ('allowed templates for children' doesn't seem to work with setImportData()? so we do it ourselves)
		return $this->extraTemplateSettings();

	}

	/**
	 * Add extra settings for the 4 dashboard-specific templates.
	 *
	 * @access private
	 * @return $this->createPages().
	 *
	 */
	private function extraTemplateSettings() {
		// 4. ###### post-creating our templates: additional settings for the child and parent notes templates ######

		$allowedChildTemplate = $this->wire('templates')->get("dashboard-note");
		$pt = $this->wire('templates')->get('dashboard-notes');

		// allowed child template for template 'dashboard-notes'
		$pt->childTemplates = array($allowedChildTemplate->id);// needs to be added as array of template IDs
		$pt->save();

		// allowed parent template for individual notes template
		// @note: this should work at JSON level but it's not, so doing it here as well
		$allowedChildTemplate->parentTemplates = array($pt->id);// needs to be added as array of template IDs
		$allowedChildTemplate->save();

		return $this->createPages();

	}

	/**
	 * Return JSON data for installing fields for the module.
	 *
	 * @access private
	 * @return string $fieldsJSON JSON string containing fields data for use with Field::setImportData().
	 *
	 */
	private function getFieldData() {
		$fieldsJSON = file_get_contents(__DIR__ . "/configs/fields.json");
		return json_decode($fieldsJSON, true);
	}

	/**
	 * Return JSON data for installing templates for the module.
	 *
	 * @access private
	 * @return string $templatesJSON JSON string containing templates data for use with Template::setImportData().
	 *
	 */
	private function getTemplateData() {
		$templatesJSON = file_get_contents(__DIR__ . "/configs/templates.json");
		return json_decode($templatesJSON, true);
	}

	/**
	 * Create notes parent page.
	 *
	 *
	 * @access private
	 *
	 */
	private function createPages() {

		// 5. ###### Create the 1 parent dashboard notes page

		$a = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$parent = $a->child('name=dashboard-notes');
		$template = $this->wire('templates')->get('dashboard-notes');

		// create the child page of 'Dashboard Notes': This is the parent page of all notes pages!
		$p = new Page();
		$p->template = $template;
		$p->parent = $parent;
		$p->title = "Notes";
		// @note: saving as hidden; we don't want to show in AdminThemeReno side menu
		$p->addStatus(Page::statusHidden);
		$p->save();

	}

}
